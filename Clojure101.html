<!DOCTYPE html>
<html>
<head>
<title>Clojure101.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="clojure-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97">Clojure 入门指南</h1>
<p>llm聊天记录：https://chat.qwen.ai/c/70478da7-880d-46b8-b9da-baa1f09c1044</p>
<h2 id="%E6%AC%A2%E8%BF%8E%E8%AF%AD">欢迎语</h2>
<p>欢迎来到 Clojure! 本指南将为你提供 Clojure 语言的基础知识。这些基础是构建性的，从第一原则出发，帮助你更容易理解未来的 Clojure 旅程。</p>
<p>掌握这些基础后，你将有更好的机会对如何编写代码、如何提出问题、如何有效搜索信息以及如何理解遇到的代码等方面拥有正确的直觉。</p>
<h2 id="1-%E8%A1%A8%E8%BE%BE%E5%BC%8F-expressions">1. 表达式 (Expressions)</h2>
<p>在 Clojure 中，一切都是表达式（没有语句）。除非在求值表达式时发生错误，否则总是有返回值（有时是 <code>nil</code>）。</p>
<p>一个重要的方面是，表达式的结果始终是最后被求值的表达式。例如：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> last-eval-wins []
  (<span class="hljs-name">println</span> 'side-effect-1)
  <span class="hljs-number">1</span>
  (<span class="hljs-name">println</span> 'side-effect-2)
  <span class="hljs-number">2</span>)
</div></code></pre>
<p>调用此函数将求值函数体中的所有四个表达式，但返回结果将是最后一个被求值的表达式。</p>
<p><code>println</code> 调用也是表达式，它们求值为 <code>nil</code>。</p>
<p>表达式由字面量（求值为自身）和/或以下之一的调用组成：</p>
<ul>
<li>特殊形式 (special forms)</li>
<li>宏 (macros)</li>
<li>函数 (functions)</li>
</ul>
<p>例如：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> foo <span class="hljs-string">"foo"</span>) <span class="hljs-comment">; 调用特殊形式 `def`</span>
(<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [x '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) 
      y '(<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:b</span>)] 
  [x y]) <span class="hljs-comment">; 调用宏 `for`</span>

(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-comment">; 调用函数 `str`</span>

(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> str [<span class="hljs-symbol">:foo</span> <span class="hljs-symbol">:bar</span>]) <span class="hljs-comment">; 函数可以作为值传递</span>
(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> for [<span class="hljs-symbol">:foo</span> <span class="hljs-symbol">:bar</span>]) <span class="hljs-comment">; 不能获取宏的值</span>
(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> def [<span class="hljs-symbol">:foo</span> <span class="hljs-symbol">:bar</span>]) <span class="hljs-comment">; def 甚至不是一个符号</span>
</div></code></pre>
<h2 id="2-%E5%AD%97%E9%9D%A2%E9%87%8F-literals">2. 字面量 (Literals)</h2>
<p>字面量求值为它们自身。</p>
<h3 id="%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</h3>
<pre class="hljs"><code><div><span class="hljs-number">18</span>        <span class="hljs-comment">; 整数</span>
<span class="hljs-number">-1.8</span>      <span class="hljs-comment">; 浮点数</span>
<span class="hljs-number">0.18</span>e<span class="hljs-number">2</span>    <span class="hljs-comment">; 指数</span>
<span class="hljs-number">18.0</span>M     <span class="hljs-comment">; 大十进制数</span>
<span class="hljs-number">18</span>/<span class="hljs-number">324</span>    <span class="hljs-comment">; 比率</span>
<span class="hljs-number">18</span>N       <span class="hljs-comment">; 大整数</span>
<span class="hljs-number">0</span>x<span class="hljs-number">12</span>      <span class="hljs-comment">; 十六进制</span>
<span class="hljs-number">022</span>       <span class="hljs-comment">; 八进制</span>
<span class="hljs-number">2</span>r<span class="hljs-number">10010</span>   <span class="hljs-comment">; 二进制</span>
</div></code></pre>
<h3 id="%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B">字符类型</h3>
<pre class="hljs"><code><div><span class="hljs-string">"hello"</span>   <span class="hljs-comment">; 字符串</span>
\e        <span class="hljs-comment">; 字符</span>
#<span class="hljs-string">"[0-9]+"</span> <span class="hljs-comment">; 正则表达式</span>
</div></code></pre>
<h3 id="%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6">符号和标识符</h3>
<pre class="hljs"><code><div>map             <span class="hljs-comment">; 符号</span>
+               <span class="hljs-comment">; 符号 - 允许大多数标点符号</span>
clojure.core/+  <span class="hljs-comment">; 命名空间符号</span>
<span class="hljs-literal">nil</span>             <span class="hljs-comment">; null/nil 值 (LISP 传统命名)</span>
<span class="hljs-literal">true</span> <span class="hljs-literal">false</span>      <span class="hljs-comment">; 布尔值</span>
<span class="hljs-symbol">:alpha</span>          <span class="hljs-comment">; 关键字</span>
<span class="hljs-symbol">:release/alpha</span>  <span class="hljs-comment">; 命名空间关键字</span>
<span class="hljs-symbol">::alpha</span>         <span class="hljs-comment">; 当前命名空间关键字</span>
</div></code></pre>
<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97-keywords">关键字 (Keywords)</h3>
<p>关键字以 <code>:</code> 开头。它们是自身，通常用作标识符和映射中的键。关键字在内存和速度方面非常高效。</p>
<p>相同的关键词不仅相等，而且是同一个对象：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-symbol">:foo</span> <span class="hljs-symbol">:foo</span>)                 <span class="hljs-comment">; true</span>
(<span class="hljs-name">identical?</span> <span class="hljs-symbol">:foo</span> <span class="hljs-symbol">:foo</span>)        <span class="hljs-comment">; true</span>
(<span class="hljs-name">identical?</span> (<span class="hljs-name"><span class="hljs-builtin-name">keyword</span></span> <span class="hljs-string">"foo"</span>) <span class="hljs-symbol">:foo</span>) <span class="hljs-comment">; true</span>
</div></code></pre>
<p>在整个 Clojure 程序中，关键字是全局的。命名空间语法可以帮助你控制这一点。</p>
<p>关键字也是函数，这在 Clojure 程序中扮演着特殊而重要的角色。</p>
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2-strings">字符串 (Strings)</h3>
<p>字符串用双引号括起来：</p>
<pre class="hljs"><code><div><span class="hljs-string">"A string can be
multi-line, but will contain any leading spaces."</span>
<span class="hljs-string">"Write strings
like this, if leading spaces are no-no."</span>
</div></code></pre>
<p>（单引号用于其他用途，稍后会看到。）</p>
<h2 id="3-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespaces">3. 命名空间 (Namespaces)</h2>
<p>命名空间非常重要，但本指南不会过多讨论。官方文档是最好的参考：
https://clojure.org/reference/namespaces</p>
<h3 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</h3>
<p>Clojure 符号在命名空间中定义（使用 <code>def</code> 特殊形式），可以从任何其他命名空间访问：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> foo-2 <span class="hljs-string">"foo"</span>)
</div></code></pre>
<p>当求值符号时，它必须已被定义，否则编译器会报错。命名空间也需要被创建。</p>
<p>通常，你会将 Clojure 代码安排到单独的文件中，每个文件一个命名空间，并使用 <code>ns</code> 形式来 <code>:require</code> 需要的命名空间，为其创建别名，有时 <code>:refer</code> 一些符号，以便无需命名空间前缀即可使用它们。</p>
<h3 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%85%B3%E9%94%AE%E5%AD%97">命名空间关键字</h3>
<p>关键字也可以有命名空间，但它们不像符号那样真正在命名空间中注册，所以你可以直接使用它们：</p>
<pre class="hljs"><code><div><span class="hljs-symbol">:foo-whatever</span>
<span class="hljs-symbol">:whatever-namespace/foo</span>
</div></code></pre>
<p>双冒号前缀 <code>::</code> 会扩展为 <code>:&lt;current-namespace&gt;/foo</code>：</p>
<pre class="hljs"><code><div><span class="hljs-symbol">::foo</span>
</div></code></pre>
<p>重要的是要知道，<code>:foo</code> 无论从哪个命名空间使用，都引用相同的关键字。而 <code>::foo</code> 则不是。</p>
<h2 id="4-%E9%9B%86%E5%90%88-collections">4. 集合 (Collections)</h2>
<p>Clojure 有四种集合类型的字面量语法，它们都求值为自身：</p>
<pre class="hljs"><code><div>'(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)     <span class="hljs-comment">; 列表 (一个引用的列表)</span>
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]      <span class="hljs-comment">; 向量</span>
#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>}     <span class="hljs-comment">; 集合</span>
{<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span>}  <span class="hljs-comment">; 映射</span>
</div></code></pre>
<p>这些集合可以组合：</p>
<pre class="hljs"><code><div>{<span class="hljs-symbol">:foo</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
 <span class="hljs-symbol">:bar</span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span>}}
</div></code></pre>
<p>在 Clojure 中，我们主要使用这些集合、字面量集合和函数来完成大多数事情。</p>
<h2 id="5-%E5%87%BD%E6%95%B0-functions">5. 函数 (Functions)</h2>
<p>到目前为止，你已经能够求值所有示例，因为我们引用了那个列表。实际上，列表看起来像这样：</p>
<pre class="hljs"><code><div>(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)
</div></code></pre>
<p>但如果你求值它，会得到错误：<code>class java.lang.Long cannot be cast to class clojure.lang.IFn</code>。当求值未引用的列表时，列表中的第一个元素被视为&quot;函数位置&quot;。这意味着 Clojure 会尝试将 <code>1</code> 作为函数调用，这不会成功，因为它不是函数。</p>
<p>你可能开始怀疑 Clojure 程序只是数据？这是正确的。Clojure 代码是数据。更准确地说，Clojure 是同像的(homoiconic)：https://wiki.c2.com/?HomoiconicLanguages。这赋予了宏强大的能力，稍后会讨论。</p>
<p>以下是一些在位置1有正确函数的列表示例：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-symbol">:foo</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span>)
(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-string">"1"</span>
   (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"1"</span>)
   (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> \<span class="hljs-number">1</span>))
(<span class="hljs-name">println</span> <span class="hljs-string">"From Clojure with ♥️"</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">reverse</span></span> [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>])
</div></code></pre>
<p>位置1之后的所有内容都作为参数传递给函数。</p>
<h3 id="%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">定义函数</h3>
<p>使用宏 <code>defn</code> 定义新函数并将其绑定到当前命名空间中的名称：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add2
  [arg]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>))
</div></code></pre>
<p>这定义了一个名为 <code>add2</code> 的函数，它接受一个参数。函数体调用核心函数 <code>+</code>，参数为 <code>arg</code> 和 2。</p>
<p>现在你可以通过将符号 <code>add2</code> 放在列表的函数位置，后跟参数来调用它：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">add2</span> <span class="hljs-number">3</span>) <span class="hljs-comment">; 返回 5</span>
</div></code></pre>
<p>Clojure 有一个庞大的核心函数库。参见：https://clojuredocs.org，这是一个社区驱动的 Clojure 核心（及更多）搜索引擎。</p>
<h2 id="6-%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F%E5%92%8C%E5%AE%8F-special-forms-and-macros">6. 特殊形式和宏 (Special Forms and Macros)</h2>
<p>核心库由库本身的函数和宏组成。引导这个库的是几个（约15个）内置原始形式，也称为&quot;特殊形式&quot;。</p>
<h3 id="%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F">特殊形式</h3>
<p>你已经遇到了其中一个特殊形式：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">quote</span></span> (<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))
</div></code></pre>
<p>符号 <code>quote</code> 的文档悬停提示会告诉你它是一个特殊形式。你之前使用了它的简写语法：</p>
<pre class="hljs"><code><div>'(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)
</div></code></pre>
<p>验证它们是相同的：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">quote</span></span> (<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))
   '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))
</div></code></pre>
<p>Clojure 有值语义。任何求值为相同数据的数据结构都是相等的，无论结构有多深或多大。</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> [<span class="hljs-number">1</span> [<span class="hljs-number">1</span> #{<span class="hljs-number">1</span> {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> '(<span class="hljs-symbol">:foo</span> bar)}}]]
   [<span class="hljs-number">1</span> [<span class="hljs-number">1</span> #{<span class="hljs-number">1</span> {<span class="hljs-symbol">:a</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>) <span class="hljs-symbol">:b</span> (<span class="hljs-name"><span class="hljs-builtin-name">quote</span></span> (<span class="hljs-symbol">:foo</span> bar))}}]]) =&gt; <span class="hljs-literal">true</span>
</div></code></pre>
<h3 id="%E9%87%8D%E8%A6%81%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F">重要特殊形式</h3>
<h4 id="fn"><code>fn</code></h4>
<p>一个非常重要的特殊形式是 <code>fn</code>（实际上是四个特殊形式，但不管怎样）。没有这个形式，我们就无法定义新函数。以下形式求值为一个函数，该函数将其参数加2：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [arg] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>))
</div></code></pre>
<p>用参数3调用该函数：</p>
<pre class="hljs"><code><div>((<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [arg] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>)) <span class="hljs-number">3</span>)
</div></code></pre>
<h4 id="def"><code>def</code></h4>
<p>另一个特殊形式是 <code>def</code>。它定义事物，给它们命名空间名称：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> foo <span class="hljs-symbol">:foo</span>)
</div></code></pre>
<p>&quot;定义一个事物&quot;意味着创建一个变量，保存值，并将符号绑定到该变量。求值符号会从它绑定的变量中获取值：</p>
<pre class="hljs"><code><div>foo
</div></code></pre>
<p>变量可以使用 <code>var</code> 特殊形式访问：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">var</span></span> foo)
</div></code></pre>
<p>你通常会看到变量引用简写：</p>
<pre class="hljs"><code><div>#'foo
</div></code></pre>
<p>使用这两个特殊形式，我们可以定义函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> add2-2 (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [arg] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>)))
(<span class="hljs-name">add2-2</span> <span class="hljs-number">3</span>)
</div></code></pre>
<p>这就是宏 <code>defn</code> 所做的事情。你通常会像下面这样定义函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add2-3
  [arg]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>))
</div></code></pre>
<p>我们可以使用函数 <code>macroexpand</code> 来查看宏产生的内容：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">macroexpand</span></span> '(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add2-3
                [arg]
                (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>)))
</div></code></pre>
<h4 id="if"><code>if</code></h4>
<p>另一个超级重要的特殊形式是 <code>if</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> 'test
  'value-if-true
  'value-if-false)
</div></code></pre>
<p><code>macroexpand</code> 在这里什么也不做，因为 <code>if</code> 不是宏（也不是函数）。</p>
<p>有趣的是：除了 <code>case</code> 之外，Clojure 中所有的条件和控制流结构都是使用 <code>if</code> 构建的：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">macroexpand</span></span> '(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> test
                value-if-true))

(<span class="hljs-name"><span class="hljs-builtin-name">macroexpand</span></span> '(<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> a b))

(<span class="hljs-name">require</span> 'clojure.walk)
(<span class="hljs-name">clojure.walk/macroexpand-all</span> '(<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> a b))

(<span class="hljs-name"><span class="hljs-builtin-name">macroexpand</span></span> '(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
                 y value-if-y
                 z value-if-z
                 <span class="hljs-symbol">:else</span> value-if-x-neither-y-nor-z))

(<span class="hljs-name">clojure.walk/macroexpand-all</span> '(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
                                 y value-if-y
                                 z value-if-z
                                 <span class="hljs-symbol">:else</span> value-if-x-neither-y-nor-z))
</div></code></pre>
<h4 id="let"><code>let</code></h4>
<p><code>let</code> is a special form that lets you bind values to
;; variables that will be used in the body of the form.</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [x <span class="hljs-number">1</span>
      y <span class="hljs-number">2</span>]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> x y))
</div></code></pre>
<p>The bindings are provided as the first ”argument”,in a vector. This is a pattern that is used by other special forms and macros that let you define bindings.</p>
<p>绑定是局部的，类似于其他编程语言的词法作用域：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">do</span></span>
  (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x <span class="hljs-symbol">:namespace-x</span>)
  (<span class="hljs-name">println</span> <span class="hljs-string">"`x` in `do` _before_ `let`: "</span> x)
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [x <span class="hljs-symbol">:let-x</span>]
    (<span class="hljs-name">println</span> <span class="hljs-string">"`x` from `let`: "</span> x))
  (<span class="hljs-name">println</span> <span class="hljs-string">"`x` in `do`, _after_ `let`: "</span> x))

(<span class="hljs-name">println</span> <span class="hljs-string">"`x` _outside_ `do`: "</span> x)
</div></code></pre>
<p>注意：<code>def</code> 特殊形式&quot;全局&quot;定义事物，尽管有命名空间。</p>
<p>特殊形式和宏的总结：特殊形式和宏构成了 Clojure 语言本身。与 Clojure 如何读取和求值代码一起，特殊形式构成了 Clojure 语言的核心。下一层次的构建块是宏。</p>
<h2 id="7-%E8%AF%BB%E5%8F%96%E5%99%A8-the-reader">7. 读取器 (The Reader)</h2>
<p>https://clojure.org/reference/reader</p>
<p>Clojure 读取器负责读取文本，从中生成数据，然后交给编译器。读取器是字面量、符号、字符串、列表、向量、映射和集合被分解和重新组装的地方，确定什么是函数、宏或特殊形式。</p>
<h3 id="%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6">空白字符</h3>
<p>大多数你认为是空白字符的东西都是空白字符，另外，Clojure 作为 LISP 不需要逗号来分隔列表项。不过，逗号可以用作分隔符，因为逗号是空白字符：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)
   '(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
   '(<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
   '(<span class="hljs-number">1</span>,,,,<span class="hljs-number">2</span>,,,,<span class="hljs-number">3</span>))
</div></code></pre>
<h3 id="%E8%A1%8C%E6%B3%A8%E9%87%8A">行注释</h3>
<p>读取器会跳过从分号开始的行上的所有内容。这是非结构化注释，如果你开始一个form</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1</span> <span class="hljs-comment">; 10)</span>
</div></code></pre>
<p>然后放置一个行注释，使该form的结束括号被注释掉，结构就会被破坏。</p>
<p>由于行上的一切都被忽略，你可以添加任意数量的分号。通常使用两个分号来开始一个完整行的注释。</p>
<h3 id="%E9%A2%9D%E5%A4%96%E8%AF%AD%E6%B3%95">额外语法</h3>
<h4 id="%E5%BC%95%E7%94%A8-quote">引用 (Quote)</h4>
<p>我们已经看到了单引号：</p>
<pre class="hljs"><code><div>'something
</div></code></pre>
<p>它被转换为：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">quote</span></span> something)
</div></code></pre>
<p><code>quote</code> 用于阻止读取器将事物视为应该被求值的东西。</p>
<h4 id="%E8%A7%A3%E5%BC%95%E7%94%A8-deref">解引用 (Deref)</h4>
<p>Clojure 也有引用类型，我们将简要讨论最常见的一个，<code>atom</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> an-atom (<span class="hljs-name"><span class="hljs-builtin-name">atom</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]))
(<span class="hljs-name"><span class="hljs-builtin-name">type</span></span> an-atom)
</div></code></pre>
<p>要从引用中访问值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">deref</span></span> an-atom)
(<span class="hljs-name"><span class="hljs-builtin-name">type</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">deref</span></span> an-atom))
</div></code></pre>
<p><code>deref</code> 如此常见，以至于有简写语法：</p>
<pre class="hljs"><code><div>@an-atom
(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">deref</span></span> an-atom)
   @an-atom)
</div></code></pre>
<p>常见错误是忘记解引用：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> an-atom) <span class="hljs-comment">; 错误</span>
(<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> @an-atom) <span class="hljs-comment">; 正确</span>
</div></code></pre>
<h4 id="%E8%B0%83%E5%BA%A6%E5%99%A8-dispatcher----%E7%AC%A6%E5%8F%B7">调度器 (Dispatcher - # 符号)</h4>
<p><code>#</code> 符号时不时出现。它有特殊作用，也称为调度。根据后面的字符，会发生不同的事情。</p>
<ul>
<li>正则表达式有字面量语法，像字符串一样写，但在前面加上 <code>#</code> 符号：</li>
</ul>
<pre class="hljs"><code><div>#<span class="hljs-string">"reg(?:ular )?exp(?:ression)?"</span>
(<span class="hljs-name">re-seq</span> *1 <span class="hljs-string">"regexp regular expression"</span>)
(<span class="hljs-name">re-seq</span> #<span class="hljs-string">"fooo*"</span> <span class="hljs-string">"fo foo fooo "</span>)
</div></code></pre>
<blockquote>
<p><code>*1</code> is a special symbol for a variable holding the value of the last evaluation result. It might be easier to get a regexp right by using it directly</p>
</blockquote>
<ul>
<li>如果 # 符号后跟 <code>(</code>，读取器将开始期待一个函数体：</li>
</ul>
<pre class="hljs"><code><div>#(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> % <span class="hljs-number">2</span>)
</div></code></pre>
<blockquote>
<p>% 是一个语法规则，表示这个匿名函数的第一个参数</p>
</blockquote>
<p>这是&quot;函数字面量&quot;的特殊语法，指定函数的一种方式。上面的示例等价于这个匿名函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [arg] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> arg <span class="hljs-number">2</span>))
</div></code></pre>
<p>嵌套函数字面量是禁止的。</p>
<ul>
<li>变量引用简写：</li>
</ul>
<pre class="hljs"><code><div>#'add<span class="hljs-number">2</span>
</div></code></pre>
<ul>
<li>读取器忽略下一个形式：</li>
</ul>
<pre class="hljs"><code><div>#_(<span class="hljs-name">println</span> <span class="hljs-string">"The reader will not send this function call to the compiler"</span>) <span class="hljs-string">"This is not ignored"</span>
</div></code></pre>
<p>这是一个结构化注释机制，通常用于临时禁用一些代码或数据：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"a "</span> <span class="hljs-string">"b "</span> #_(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]) <span class="hljs-string">"c "</span>) =&gt; <span class="hljs-string">"abc"</span>
</div></code></pre>
<p>忽略标记可以堆叠：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"a "</span> #_#_ <span class="hljs-string">"b "</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]) <span class="hljs-string">"c "</span>) =&gt; <span class="hljs-string">"ac"</span>
</div></code></pre>
<p>注意：读取器_会_读取被忽略的形式。如果其中有语法错误，读取器会报错。</p>
<ul>
<li>命名空间映射关键字简写语法：</li>
</ul>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> #:foo {<span class="hljs-symbol">:bar</span> 'bar
          <span class="hljs-symbol">:baz</span> 'baz}
   {<span class="hljs-symbol">:foo/bar</span> 'bar
    <span class="hljs-symbol">:foo/baz</span> 'baz})
</div></code></pre>
<blockquote>
<p>就是用 #:foo {:bar 'bar ...} 给字典里的key的命名空间加前缀?</p>
</blockquote>
<ul>
<li>双冒号关键字用当前命名空间命名：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-symbol">::foo</span>
(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-symbol">::foo</span> <span class="hljs-symbol">:current-namespace/foo</span>)
</div></code></pre>
<ul>
<li>标记字面量（也称为数据读取器）：</li>
</ul>
<pre class="hljs"><code><div>#inst <span class="hljs-string">"2018-03-28T10:48:00.000"</span> <span class="hljs-comment">; 转换为时间点</span>
#uuid <span class="hljs-string">"0000000-0000-0000-0000-000000000016"</span> <span class="hljs-comment">; 生成UUID</span>
</div></code></pre>
<blockquote>
<p>会将这些转成java类型</p>
</blockquote>
<p>Java 互操作示例：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">.before</span> #inst <span class="hljs-string">"2018-03-28T10:48:00.000"</span>
         #inst <span class="hljs-string">"2021-02-17T00:27:00.000"</span>)
</div></code></pre>
<h2 id="8-%E5%AE%8F-macros">8. 宏 (Macros)</h2>
<p>Clojure 有强大的数据转换能力。这里我想强调的是，这种能力可以用于扩展语言本身。由于 Clojure 代码是结构化的，代码是数据，Clojure 可以用于从 Clojure 代码生成 Clojure 代码。这类似于某些语言提供的预处理器功能（如 C 的 <code>#pragma</code>），但它更方便、更强大。很多你将学会喜爱并认出的 Clojure 其实是用 Clojure 作为宏创建的。</p>
<p>本指南主要关注让你知道宏是一种东西，帮助你快速意识到何时使用宏而非函数。即，我不会深入讨论如何创建宏。</p>
<h3 id="%E5%8C%BA%E5%88%AB">区别</h3>
<p>这种区别很重要，因为即使宏调用看起来很像函数调用，宏不是一等公民。它们不能作为参数传递，也不能作为结果返回。</p>
<h3 id="when-%E5%AE%8F"><code>when</code> 宏</h3>
<p>让我们简要检查 <code>when</code> 宏。这个宏有助于编写更易读的代码。假设你想条件性地求值某些内容。上面你了解到有一个名为 <code>if</code> 的特殊形式可用于此：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> 'this-is-true
  'evaluate-this
  'else-evaluate-this)
</div></code></pre>
<p>现在假设在 else 情况下你没有要评估的内容。<code>if</code> 允许你这样写：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> 'this-is-true
  'evaluate-this)
</div></code></pre>
<p>这很好，但你必须额外扫描代码才能看到没有 else 分支。在真实代码中，这可能会变得相当混乱。为了解决这个问题，你可以写：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> 'this-is-true
  'evaluate-this
  <span class="hljs-literal">nil</span>)
</div></code></pre>
<p>但这有点傻，如果有办法告诉阅读代码的人没有 else 分支呢？有！</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> 'this-is-true
  'evaluate-this)
</div></code></pre>
<p>让我们看看 <code>when</code> 是如何定义的，你可以 ctrl/cmd-click <code>when</code> 导航到 Clojure <code>core.clj</code> 中定义它的地方。你也可以使用函数 <code>macroexpand</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">macroexpand</span></span> '(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> 'this-is-true
                'evaluate-this))
</div></code></pre>
<p>你会注意到 <code>when</code> 将主体包装在 <code>(do ...)</code> 中，这是一个特殊形式，允许你求值多个表达式，返回最后一个的结果。<code>do</code> 在你想要有一些副作用，以及求值某些内容时很有用。在开发中，当你想在表达式求值并返回结果之前 <code>println</code> 某些内容时，经常会发生这种情况：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">do</span></span> (<span class="hljs-name">println</span> <span class="hljs-string">"The quick brown fox jumps over the lazy dog"</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>))
</div></code></pre>
<p><code>when</code> 宏让你利用只有一个分支这一事实，所以你可以这样做：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> 'this-is-true
  (<span class="hljs-name">println</span> <span class="hljs-string">"The quick brown fox jumps over the lazy dog"</span>)
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>))
</div></code></pre>
<p>没有 <code>when</code> 你会写：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> 'this-is-true
  (<span class="hljs-name"><span class="hljs-builtin-name">do</span></span>
    (<span class="hljs-name">println</span> <span class="hljs-string">"The quick brown fox jumps over the lazy dog"</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>)))
</div></code></pre>
<p>在这里，<code>when</code> 既省去了额外扫描 else 分支的麻烦，也省去了使用 <code>do</code> 的麻烦。</p>
<p>就宏而言，<code>when</code> 是最简单的之一。从两个内置特殊形式 <code>if</code> 和 <code>do</code>，它组合成一种形式，帮助我们编写易于编写和阅读的代码。</p>
<h3 id="for-%E5%AE%8F"><code>for</code> 宏</h3>
<p><code>for</code> 宏真正展示了如何使用 Clojure 扩展 Clojure。你可能会认为它提供了像许多其他语言中的 for 循环那样的循环，但在 Clojure 中没有 for 循环。相反，<code>for</code> 是关于列表推导（如果你有 Python 经验，是的，就是那种列表推导）。以下是生成两个向量 <code>x</code> 和 <code>y</code> 的笛卡尔积的方法：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [x [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
      y [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]]
  [x y])
</div></code></pre>
<p>如果你记得上面的 <code>let</code> form，以及它如何让你绑定变量在form主体中使用，这很相似，只是 <code>x</code> 和 <code>y</code> 将绑定到序列中的每个值，并且主体将为 <code>x</code> 和 <code>y</code> 的所有组合求值。</p>
<p><code>for</code> 也允许你过滤结果：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [x [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
      y [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]
      <span class="hljs-symbol">:when</span> (<span class="hljs-name"><span class="hljs-builtin-name">not=</span></span> x y)]
  [x y])
</div></code></pre>
<p>你可以在推导中绑定变量名以存储中间计算并使代码更具可读性：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [x [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
      y [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]
      <span class="hljs-symbol">:let</span> [d' (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x y)
            d (<span class="hljs-name">Math/abs</span> d')]]
  d)
</div></code></pre>
<p>这与下面等价：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [x [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
      y [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]]
  (<span class="hljs-name">Math/abs</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x y)))
</div></code></pre>
<p>过滤器和绑定可以一起使用。使用 <code>:let</code> 和 <code>:when</code> 使这个推导返回所有 <code>[x y]</code> 的列表，其中它们的和是奇数。函数 <code>+</code> 和 <code>odd?</code> 是你的好朋友。</p>
<h3 id="%E7%BA%BF%E7%A8%8B%E5%AE%8F-threading-macros">线程宏 (Threading Macros)</h3>
<p>宏可以完全重新排列你的代码。内置的&quot;线程&quot;宏就是如此。有时当函数(-ish)调用的嵌套变深时，可能会有点难读，难以跟踪所有的括号：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">Math/abs</span>
 (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> -
        (<span class="hljs-symbol">:d</span> (<span class="hljs-name"><span class="hljs-builtin-name">zipmap</span></span>
             [<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:b</span> <span class="hljs-symbol">:c</span> <span class="hljs-symbol">:d</span>]
             (<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> <span class="hljs-number">2</span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])))))
</div></code></pre>
<p>你从最内层表达式向外读 Clojure，这随着时间的推移会变得更容易，但一个经验丰富的 Clojure 程序员仍然会觉得这个更易读：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>]
     (<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> <span class="hljs-number">2</span>)
     (<span class="hljs-name"><span class="hljs-builtin-name">zipmap</span></span> [<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:b</span> <span class="hljs-symbol">:c</span> <span class="hljs-symbol">:d</span>])
     <span class="hljs-symbol">:d</span>
     (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> -)
     (<span class="hljs-name">Math/abs</span>))
</div></code></pre>
<p>Let's read this together. The thread-last macro,
<code>-&gt;&gt;</code> is used, it takes its first argument and
places it (threads it) as the last argument to
following function. The first such step in
isolation:</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>]
       (<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> <span class="hljs-number">2</span>))
</div></code></pre>
<p>The first argument/element passed to <code>-&gt;&gt;</code> is <code>[1 1 2 3 5 8 13 21]</code>
This is inserted as the last element of the
function call <code>(partition 2)</code>, yielding:</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> <span class="hljs-number">2</span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>This partitions the list into lists of 2 elements =&gt; <code>((1 1) (2 3) (5 8) (13 21))</code>
This new list is then inserted (threaded) as the last argument to the next function, yielding:</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">zipmap</span></span> [<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:b</span> <span class="hljs-symbol">:c</span> <span class="hljs-symbol">:d</span>] '((<span class="hljs-number">1</span> <span class="hljs-number">1</span>) (<span class="hljs-number">2</span> <span class="hljs-number">3</span>) (<span class="hljs-number">5</span> <span class="hljs-number">8</span>) (<span class="hljs-number">13</span> <span class="hljs-number">21</span>)))
</div></code></pre>
<p>Which ”zips” together a Clojure map using the first list as keys and the second list as values  =&gt; <code>{:a (1 1), :b (2 3), :c (5 8), :d (13 21)}</code> . This map is then threaded as the last argument to the function <code>:d</code>.</p>
<pre class="hljs"><code><div>(<span class="hljs-symbol">:d</span> '{<span class="hljs-symbol">:a</span> (<span class="hljs-number">1</span> <span class="hljs-number">1</span>), <span class="hljs-symbol">:b</span> (<span class="hljs-number">2</span> <span class="hljs-number">3</span>), <span class="hljs-symbol">:c</span> (<span class="hljs-number">5</span> <span class="hljs-number">8</span>), <span class="hljs-symbol">:d</span> (<span class="hljs-number">13</span> <span class="hljs-number">21</span>)})
</div></code></pre>
<p>(In clojure keywords are functions that look themselves up in the map handed to them.) =&gt; <code>(13 21)</code>
You know the drill by now, this is threaded</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> - '(<span class="hljs-number">13</span> <span class="hljs-number">21</span>))
</div></code></pre>
<p>which applies the <code>-</code> function over the list =&gt; <code>-8</code>, Then this is threaded to <code>Math/abs</code></p>
<pre class="hljs"><code><div>(<span class="hljs-name">Math/abs</span> <span class="hljs-number">-8</span>)
</div></code></pre>
<p>There is also a  hread-first macro <code>-&gt;</code></p>
<ul>
<li>https://clojuredocs.org/clojure.core/-%3E</li>
</ul>
<p>Sometimes you neither want to thread first or last。也有一个宏用于此。<code>as-&gt;</code> 允许你将变量名绑定到线程化的东西，并在每个函数调用中将其放在你喜欢的任何位置：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">as-&gt;</span> <span class="hljs-number">15</span> foo
  (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1</span> foo <span class="hljs-number">3</span>)
  (<span class="hljs-name">interpose</span> <span class="hljs-string">": "</span> foo))
</div></code></pre>
<p>It's common to utilize the fact that most characters are available when naming Clojure symbols. I often
use <code>$</code> for this threading macro:</p>
<pre class="hljs"><code><div>(<span class="hljs-name">as-&gt;</span> <span class="hljs-number">15</span> $
  (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1</span> $ <span class="hljs-number">3</span>)
  (<span class="hljs-name">interpose</span> <span class="hljs-string">":"</span> $))
</div></code></pre>
<p>其他核心线程宏包括：<code>cond-&gt;</code>, <code>cond-&gt;&gt;</code>, <code>some-&gt;</code>, 和 <code>some-&gt;&gt;</code> https://clojuredocs.org/clojure.core/cond-%3E</p>
<h2 id="9-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%88%86%E6%94%AF-flow-control-conditionals-branching">9. 流程控制、条件语句、分支 (Flow Control, Conditionals, Branching)</h2>
<p>Clojure 的控制流语法很丰富。核心库中几乎所有相关的功能都是使用原始的<code>if</code> 实现的。它接受三个形式作为参数：</p>
<ol>
<li>要求值的条件</li>
<li>如果条件求值为真（truthy）则要评估的内容</li>
<li>如果条件不求值为真（&quot;else&quot; 分支）则要评估的形式</li>
</ol>
<p>掷骰子，十到二十次，检查是否是6：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-builtin-name">inc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">rand-int</span></span> <span class="hljs-number">6</span>)))
  <span class="hljs-string">"One time out of six you get a six"</span>
  <span class="hljs-string">"Five times out of six you get something else"</span>)
</div></code></pre>
<p>由于 Clojure 中没有语句，<code>if</code> 相当于你在 C 和许多其他语言中找到的三元 <code>if</code> 表达式：</p>
<pre class="hljs"><code><div>test ? <span class="hljs-literal">true</span>-expression : <span class="hljs-literal">false</span>-expression
</div></code></pre>
<h3 id="%E7%9C%9F%E7%90%86%E7%9A%84%E6%8E%A2%E7%B4%A2">真理的探索</h3>
<p>再次，在 Clojure 中我们使用求值为值的表达式。当检查分支时，所有值要么是真值，要么是假值。事实上，几乎所有值都是真值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-literal">true</span> <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>) =&gt; <span class="hljs-symbol">:truthy</span>
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-symbol">:foo</span> <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> '() <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-number">0</span> <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-string">" "</span> <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>)
</div></code></pre>
<p>唯一的假值是 <code>false</code> 和 <code>nil</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-literal">false</span> <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>) =&gt; <span class="hljs-symbol">:falsy</span>
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-literal">nil</span> <span class="hljs-symbol">:truthy</span> <span class="hljs-symbol">:falsy</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> <span class="hljs-literal">false</span> <span class="hljs-symbol">:truthy</span>)
</div></code></pre>
<p>关于最后一个：当条件为假时，<code>when</code> 求值为 <code>nil</code>。由于 <code>nil</code> 是假值，上面的 <code>when</code> 表达式会使 <code>if</code> 的&quot;else&quot;分支被评估：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> <span class="hljs-literal">false</span> <span class="hljs-symbol">:truthy</span>) <span class="hljs-symbol">:true</span> <span class="hljs-symbol">:falsy</span>) 
</div></code></pre>
<p>（超糟糕的代码，但无论如何）</p>
<p>当只有布尔真或假可以为你解决问题时，有 <code>true?</code> 函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">true?</span></span> <span class="hljs-literal">true</span>) =&gt; <span class="hljs-literal">true</span>
(<span class="hljs-name"><span class="hljs-builtin-name">true?</span></span> <span class="hljs-number">0</span>)  =&gt; <span class="hljs-literal">false</span>
(<span class="hljs-name"><span class="hljs-builtin-name">true?</span></span> '()) =&gt; <span class="hljs-literal">false</span>
(<span class="hljs-name"><span class="hljs-builtin-name">true?</span></span> <span class="hljs-literal">nil</span>) =&gt; <span class="hljs-literal">false</span>
(<span class="hljs-name"><span class="hljs-builtin-name">true?</span></span> <span class="hljs-literal">false</span>) =&gt; <span class="hljs-literal">false</span>
</div></code></pre>
<p>因此：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">true?</span></span> <span class="hljs-number">0</span>) <span class="hljs-symbol">:true</span> <span class="hljs-symbol">:false</span>)
</div></code></pre>
<h3 id="when"><code>when</code></h3>
<p>正如之前提到的，<code>when</code> 是一个单分支 <code>if</code>，仅用于真分支，并为你包装在 <code>do</code> 中。尝试这个，然后尝试用 <code>if</code> 替换 <code>when</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> <span class="hljs-symbol">:truthy</span>
  (<span class="hljs-name">println</span> <span class="hljs-string">"That sounds true to me"</span>)
  <span class="hljs-symbol">:truthy-for-you</span>)
</div></code></pre>
<p>如果 <code>when</code> 条件不是真值，将返回 <code>nil</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> <span class="hljs-literal">nil</span> <span class="hljs-symbol">:true-enough?</span>)
</div></code></pre>
<h3 id="cond"><code>cond</code></h3>
<p>由于深度嵌套的 if/else 结构可能难以编写、阅读和维护，Clojure 核心提供了几种更多的流程控制结构，一个非常常见的是 <code>cond</code> 宏。它接受条件/结果形式对，测试每个条件，如果为真，则求值结果形式并&quot;返回&quot;它，短路以便不再测试更多条件：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [dice-roll (<span class="hljs-name"><span class="hljs-builtin-name">inc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">rand-int</span></span> <span class="hljs-number">6</span>))]
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
    (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-number">6</span> dice-roll)   <span class="hljs-string">"Six is as high as it gets"</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">odd?</span></span> dice-roll) (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"An odd roll "</span> dice-roll <span class="hljs-string">" is"</span>)
    <span class="hljs-symbol">:else</span>            (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"Not six, nor odd, instead: "</span> dice-roll)))
</div></code></pre>
<p><code>:else</code> 只是关键字 <code>:else</code>，它求值为自身并且是真值。它是为你的 cond 形式提供默认值的常规方式。如果没有默认子句<code>:else</code>，这个form会对任何非六非奇数求值为 <code>nil</code>。通过在 <code>:else</code> 关键字前放置两个忽略标记 (<code>#_ #_</code>) 来尝试。</p>
<h3 id="case"><code>case</code></h3>
<p>有点类似于其他语言中的 <code>switch/case</code> 结构，Clojure 核心有 <code>case</code> 宏，它接受一个测试表达式，后跟零个或多个测试常量/表达式对，后跟一个可选表达式。（然而，测试表达式后的主体不能为空。）</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [test-str <span class="hljs-string">"foo bar"</span>]
  (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> test-str
    <span class="hljs-string">"foo bar"</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"That's very "</span> <span class="hljs-symbol">:foo-bar</span>)
    <span class="hljs-string">"baz"</span>     <span class="hljs-symbol">:baz</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> test-str)))
</div></code></pre>
<p>尾随表达式（如果有）作为默认值&quot;返回&quot;。</p>
<p>如果没有子句匹配且没有默认值，会发生运行时错误。</p>
<p>注意！测试常量必须是编译时常量，编译器不会帮你找到像这样的错误：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [test-int <span class="hljs-number">2</span>
      two <span class="hljs-number">2</span>]
  (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> test-int
    <span class="hljs-number">1</span>     <span class="hljs-symbol">:one</span>
    two   (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"That's not a literal 2"</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> test-int <span class="hljs-string">": Probably not expected"</span>)))
</div></code></pre>
<h3 id="%E5%87%8F%E5%B0%91%E5%88%86%E6%94%AF">减少分支</h3>
<p>核心库中有丰富的函数，可以帮助你避免编写分支代码。相反，你提供条件作为谓词。一个常用的谓词函数是 <code>filter</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even? [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>])
</div></code></pre>
<p>和它的&quot;兄弟&quot; <code>remove</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">remove</span></span> odd? [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>])
</div></code></pre>
<p>过滤值序列是常见任务，你的编程时间可以用来决定_如何_过滤，通过编写谓词。有时你甚至不需要这样做，Clojure 核心中有很多谓词：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> <span class="hljs-number">0</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">even?</span></span> <span class="hljs-number">0</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">neg?</span></span> <span class="hljs-number">0</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">pos?</span></span> <span class="hljs-number">0</span>)
(<span class="hljs-name">nat-int?</span> <span class="hljs-number">0</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">empty?</span></span> <span class="hljs-string">" "</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">empty?</span></span> [])
(<span class="hljs-name"><span class="hljs-builtin-name">empty?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">0</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]))
(<span class="hljs-name"><span class="hljs-builtin-name">integer?</span></span> <span class="hljs-number">-2</span>/<span class="hljs-number">1</span>)
(<span class="hljs-name">indexed?</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])
(<span class="hljs-name">indexed?</span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))
</div></code></pre>
<p>什么是谓词？就本指南而言，谓词是一个测试事物真值的函数。按照约定，这些函数以 <code>?</code> 结尾。许多只接受一个参数。</p>
<p>一个方便的谓词是 <code>some?</code>，它测试&quot;某物性&quot;，如果不是 <code>nil</code>，就是某物：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">some?</span> <span class="hljs-literal">nil</span>)
(<span class="hljs-name">some?</span> <span class="hljs-literal">false</span>)
(<span class="hljs-name">some?</span> '())
</div></code></pre>
<p>你可以用它来测试某物是否为 <code>nil</code>，通过将其包装在对 <code>not</code> 函数的调用中：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name">some?</span> <span class="hljs-literal">nil</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name">some?</span> <span class="hljs-literal">false</span>))
</div></code></pre>
<p>你会有冲动定义一个名为 <code>nil?</code> 的函数，对吧？你不需要：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">nil?</span></span> <span class="hljs-literal">nil</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">nil?</span></span> <span class="hljs-literal">false</span>)
</div></code></pre>
<p>Clojure 核心还包含接受谓词加集合以应用它的谓词。例如 <code>every?</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">every?</span> nat-int? [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>])
(<span class="hljs-name">every?</span> nat-int? [<span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>])
</div></code></pre>
<p>这种带函数作为参数的函数模式在 Clojure 中很常见。它超出了谓词。接受函数作为参数的函数被称为&quot;高阶函数&quot;。
https://en.wikipedia.org/wiki/Higher-order_function</p>
<h2 id="10-%E5%87%BD%E6%95%B0-functions---%E6%B7%B1%E5%85%A5">10. 函数 (Functions) - 深入</h2>
<p>在深入高阶函数之前，让我们看一下函数。函数是 Clojure 的一等公民，是解决业务问题的主要构建块。</p>
<p>我们已经看到了几种创建函数的方法。这是一个匿名函数，返回给它的整数，除非它能被 15 整除，此时它返回 <code>&quot;fizz buzz&quot;</code>。（这不是完整的 Fizz Buzz 问题。）</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [n]
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">mod</span></span> n <span class="hljs-number">15</span>))
    <span class="hljs-string">"fizz buzz"</span>
    n))
</div></code></pre>
<p>让我们定义它（将其绑定到我们可以使用的符号）：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> fizz-buzz-1 (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [n]
                   (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">mod</span></span> n <span class="hljs-number">15</span>))
                     <span class="hljs-string">"fizz buzz"</span>
                     n)))
(<span class="hljs-name">fizz-buzz-1</span> <span class="hljs-number">2</span>)
(<span class="hljs-name">fizz-buzz-1</span> <span class="hljs-number">15</span>)
</div></code></pre>
<p>There's a macro that lets us define and create the function in one call：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fizz-buzz-2 [n]
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">mod</span></span> n <span class="hljs-number">15</span>))
    <span class="hljs-string">"fizz buzz"</span>
    n))

(<span class="hljs-name">fizz-buzz-2</span> <span class="hljs-number">4</span>)
</div></code></pre>
<p><code>defn</code> 允许我们为函数提供文档：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fizz-buzz-3
  <span class="hljs-string">"Says 'fizz buzz' if `n` is divisible by 15,
  otherwise says `n`"</span>
  [n]
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">mod</span></span> n <span class="hljs-number">15</span>))
    <span class="hljs-string">"fizz buzz"</span>
    n))

(<span class="hljs-name">doc</span> fizz-buzz-3) <span class="hljs-comment">; (或悬停 `fizz-buzz-3`)</span>
</div></code></pre>
<p>很容易放错文档字符串的位置，特别是因为通常像上面的 <code>fizz-buzz-2</code> 一样编写 <code>defn</code> 形式：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fizz-buzz-4
  [n]
  <span class="hljs-string">"Says 'fizz buzz' if `n` is divisible by 15,
  otherwise says `n`"</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">mod</span></span> n <span class="hljs-number">15</span>))
    <span class="hljs-string">"fizz buzz"</span>
    n))
</div></code></pre>
<p>这指定了一个完全有效的函数体，所以 Clojure 不会对此抱怨。但是：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">doc</span> fizz-buzz-4) =&gt; <span class="hljs-literal">nil</span> 
</div></code></pre>
<blockquote>
<p>这说明文档字符串放置的位置不对，导致文档系统无法识别这个字符串作为文档</p>
</blockquote>
<p>clj-kondo 的默认配置会帮你发现这些错误。然而，它无法帮你解决这个问题：</p>
<blockquote>
<p>clj-kondo 是一个静态代码检测工具</p>
</blockquote>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> only-the-last-eval-returns [x]
  [<span class="hljs-number">1</span> x]
  [<span class="hljs-number">2</span> x])

(<span class="hljs-name">only-the-last-eval-returns</span> <span class="hljs-string">"foo"</span>)
</div></code></pre>
<p>像这样很容易发现，你可能会想知道为什么你会这样写一个函数。然而，你可能会犯这个错误，特别是如果你曾经写过一些 Hiccup，这是一种用 Clojure 数据结构编写 HTML 的超好方法。它被流行的 Reagent 库使用 https://purelyfunctional.tv/guide/reagent/#hiccup</p>
<p>当你犯这个错误并完成你的一小时 bug 追踪时，你会听到本指南低语&quot;告诉过你！&quot;</p>
<p><code>fn</code>（ <code>defn</code>也是 ）的参数绑定向量按顺序将每个参数绑定到一个名称：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> coords-&gt;str [x y]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"x: "</span> x <span class="hljs-string">", y: "</span> y))
</div></code></pre>
<h3 id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0-variadic-functions">可变参数函数 (Variadic Functions)</h3>
<p>你可以定义接受任意数量参数的函数，方法是在最后一个参数名前放置 <code>&amp;</code>。这将名称绑定到一个包含所有剩余参数的序列：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> lead+members [lead &amp; members]
  {<span class="hljs-symbol">:lead</span> lead
   <span class="hljs-symbol">:members</span> members})

(<span class="hljs-name">lead+members</span> <span class="hljs-string">"Dave Mustain"</span>
              <span class="hljs-string">"Marty Friedman"</span>
              <span class="hljs-string">"Nick Menza"</span>
              <span class="hljs-string">"David Ellefson"</span>)
</div></code></pre>
<h3 id="%E5%A4%9A%E9%87%8D%E5%85%83%E6%95%B0-multi-arity">多重元数 (Multi-arity)</h3>
<p>Clojure 支持基于参数数量的函数签名。<code>defn</code> 宏允许你将每个元数定义为一个单独的列表。这通常用于提供默认值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> hello
  ([] (<span class="hljs-name">hello</span> <span class="hljs-string">"World"</span>))
  ([s] (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"Hello "</span> s <span class="hljs-string">"!"</span>)))

(<span class="hljs-name">hello</span>)
(<span class="hljs-name">hello</span> <span class="hljs-string">"Clojure Friend"</span>)
</div></code></pre>
<p>或者为函数创建一个&quot;标识&quot;值（一个起始值，操作的其余部分使用）。假设你想添加两个 x-y 坐标：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add-coords-1 [coord-1 coord-2]
  {<span class="hljs-symbol">:x</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:x</span> coord-1)
         (<span class="hljs-symbol">:x</span> coord-2))
   <span class="hljs-symbol">:y</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:y</span> coord-1)
         (<span class="hljs-symbol">:y</span> coord-2))})

(<span class="hljs-name">add-coords-1</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">-2</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">10</span>}
               {<span class="hljs-symbol">:x</span> <span class="hljs-number">4</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">6</span>})
</div></code></pre>
<p>如果要求是，如果函数被调用时只有一个参数，它应该将其添加到原点？（看到我做了什么吗？函数的标识是函数应该开始的地方，所以从原点开始。😎）我们可以看到 <code>add-coords-1</code> 在这里失败：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">add-coords-1</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">-2</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">10</span>})
</div></code></pre>
<p>我们需要添加一个一元数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add-coords-2
  ([coord]
   (<span class="hljs-name">add-coords-2</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">0</span>
                  <span class="hljs-symbol">:y</span> <span class="hljs-number">0</span>}
                 coord))
  ([coord-1 coord-2]
   {<span class="hljs-symbol">:x</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:x</span> coord-1)
          (<span class="hljs-symbol">:x</span> coord-2))
    <span class="hljs-symbol">:y</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:y</span> coord-1)
          (<span class="hljs-symbol">:y</span> coord-2))}))

(<span class="hljs-name">add-coords-2</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">-2</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">10</span>})
</div></code></pre>
<p>现在，如果用没有参数调用，它应该返回原点，因为如果你不添加任何坐标，你就停留在起点。编写一个函数 <code>add-coords-3</code>，当像这样调用时返回原点：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">add-coords-3</span>)
</div></code></pre>
<p>它仍然应该能够像这样调用：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">add-coords-3</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">3</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">4</span>})
(<span class="hljs-name">add-coords-3</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">2</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">4</span>}
              {<span class="hljs-symbol">:x</span> <span class="hljs-number">-4</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">-4</span>})
</div></code></pre>
<p>这与让函数与其他函数组合有关。例如，高阶函数 <code>apply</code>，它在一个序列上&quot;应用&quot;一个函数。现在我们可以像这样应用我们的 <code>add-coords-2</code> 函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-coords-2 [{<span class="hljs-symbol">:x</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">1</span>} {<span class="hljs-symbol">:x</span> <span class="hljs-number">4</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">4</span>}])
</div></code></pre>
<p>和这样：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-coords-2 [{<span class="hljs-symbol">:x</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:y</span> <span class="hljs-number">1</span>}])
</div></code></pre>
<p>但不能这样：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-coords-2 [])
</div></code></pre>
<p>但你创建的 <code>add-coords-3</code> 函数可以：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-coords-3 [])
</div></code></pre>
<p>它无法处理任意长的坐标序列。为此，我们需要再添加一个元数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add-coords-4
  <span class="hljs-comment">;; 在这里添加你的 `add-coords-3` 的零元数</span>
  <span class="hljs-comment">;; 在这里添加你的 `add-coords-3` 的一元数</span>
  ([coord-1 coord-2]
   {<span class="hljs-symbol">:x</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:x</span> coord-1)
          (<span class="hljs-symbol">:x</span> coord-2))
    <span class="hljs-symbol">:y</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:y</span> coord-1)
          (<span class="hljs-symbol">:y</span> coord-2))})
  ([coord-1 coord-2 &amp; more-coords]
   <span class="hljs-comment">;; 当你了解高阶函数 `reduce` 后实现这个元数</span>
   ))
</div></code></pre>
<p>听 Eric Normand 详细解释为什么函数的标识很重要：
https://lispcast.com/what-is-a-functions-identity/</p>
<h3 id="%E9%97%AD%E5%8C%85-closures">闭包 (Closures)</h3>
<p>当你即时创建函数，lambda，如果你喜欢，你可以直接使用 <code>fn</code> 特殊形式，或通过 <code>#()</code> 语法代理。这创建了一个闭包，就像在 JavaScript 和其他语言中一样。也就是说，这些函数可以访问在创建函数时变量的快照值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> named-coords-factory [name]
  (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [x y] {<span class="hljs-symbol">:name</span> name
             <span class="hljs-symbol">:coords</span> {<span class="hljs-symbol">:x</span> x
                      <span class="hljs-symbol">:y</span> y}}))

(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> bob-coords-fn (<span class="hljs-name">named-coords-factory</span> <span class="hljs-string">"Bob"</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> fred-coords-fn (<span class="hljs-name">named-coords-factory</span> <span class="hljs-string">"Fred"</span>))

(<span class="hljs-name">bob-coords-fn</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>)
(<span class="hljs-name">fred-coords-fn</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span>)
(<span class="hljs-name">bob-coords-fn</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span>)
</div></code></pre>
<p>闭包对于在 let 绑定框内创建低元数函数很有用，函数体可以使用：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> whisper-or-yell-or-ask [command sentence]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [whisper (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> []
                  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> (<span class="hljs-name">string/lower-case</span> sentence) command))
        yell (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> []
               (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> (<span class="hljs-name">string/upper-case</span> sentence) command))
        ask (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> []
              (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> sentence <span class="hljs-string">"?"</span>))
        default (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> []
                  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> sentence command <span class="hljs-string">" ¯\\_(ツ)_/¯"</span>))]
    (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> command
      <span class="hljs-string">" "</span> (<span class="hljs-name">whisper</span>)
      <span class="hljs-string">"! "</span> (<span class="hljs-name">yell</span>)
      <span class="hljs-string">"? "</span> (<span class="hljs-name">ask</span>)
      (<span class="hljs-name">default</span>))))
</div></code></pre>
<p>在 let 绑定框中创建的所有函数都&quot;闭合&quot;了 <code>command</code> 和 <code>sentence</code>，所以 <code>case</code> 可以保持简洁易读：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">whisper-or-yell-or-ask</span> <span class="hljs-string">" "</span> <span class="hljs-string">"How wOnDerFuLLY NIce To seE"</span>)
(<span class="hljs-name">whisper-or-yell-or-ask</span> <span class="hljs-string">"! "</span> <span class="hljs-string">"Hello tHERE"</span>)
(<span class="hljs-name">whisper-or-yell-or-ask</span> <span class="hljs-string">"? "</span> <span class="hljs-string">"How are you doing"</span>)
(<span class="hljs-name">whisper-or-yell-or-ask</span> <span class="hljs-string">": "</span> <span class="hljs-string">"Oh well"</span>)
</div></code></pre>
<h3 id="%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84-attributes-map">属性映射 (Attributes Map)</h3>
<p><code>defn</code> 宏允许你以映射形式向函数添加属性。这作为元数据（稍后会更多关于这一点）添加到保存函数的变量。映射放在函数名之后，任何文档之后，参数向量（或任何元数）之前：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> i-have-attributes
  {<span class="hljs-symbol">:doc</span> <span class="hljs-string">"Docs can be added like this too"</span>
   <span class="hljs-symbol">:foo</span> <span class="hljs-string">"Any attributes you fancy"</span>}
  []
  <span class="hljs-string">"Good for you"</span>)

(<span class="hljs-name">doc</span> i-have-attributes)
(<span class="hljs-name"><span class="hljs-builtin-name">meta</span></span> #'i-have-attributes)
</div></code></pre>
<p>你可以添加的一个方便属性是测试函数。测试运行器会获取这个：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fizz-buzz-5
  <span class="hljs-string">"That limited fizz-buzz function again"</span>
  {<span class="hljs-symbol">:test</span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> []
           (<span class="hljs-name">is</span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-string">"fizz-buzz"</span> (<span class="hljs-name">fizz-buzz-5</span> <span class="hljs-number">15</span>)))
           (<span class="hljs-name">is</span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-number">3</span> (<span class="hljs-name">fizz-buzz-5</span> <span class="hljs-number">3</span>))))}
  [n]
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">pos?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">rem</span></span> <span class="hljs-number">15</span> n))
    <span class="hljs-string">"fizz-buzz"</span>
    n))

(<span class="hljs-name">clojure.test/test-var</span> #'fizz-buzz-5)
</div></code></pre>
<p>需要修复 bug。😀</p>
<p>如何实现完整的 Fizz Buzz？
https://en.wikipedia.org/wiki/Fizz_buzz</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fizz-buzz
  <span class="hljs-string">"My Fizz Buzz solution"</span>
  {<span class="hljs-symbol">:test</span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> []
           (<span class="hljs-name">are</span> [arg expected]
                (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> expected (<span class="hljs-name">fizz-buzz</span> arg))
             <span class="hljs-number">1</span>  <span class="hljs-number">1</span>
             <span class="hljs-number">3</span>   <span class="hljs-string">"Fizz"</span>
             <span class="hljs-number">4</span>  <span class="hljs-number">4</span>
             <span class="hljs-number">5</span>   <span class="hljs-string">"Buzz"</span>
             <span class="hljs-number">7</span>  <span class="hljs-number">7</span>
             <span class="hljs-number">15</span>  <span class="hljs-string">"Fizz Buzz"</span>
             <span class="hljs-number">20</span>  <span class="hljs-string">"Buzz"</span>))}
  [n])

(<span class="hljs-name">clojure.test/test-var</span> #'fizz-buzz)
(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> fizz-buzz (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1</span> <span class="hljs-number">40</span>))
</div></code></pre>
<p>对编译器和各种 Clojure 核心设施有特殊意义的元数据列在这里：
https://clojure.org/reference/special_forms</p>
<p>现在，进入高阶函数！</p>
<h2 id="11-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-higher-order-functions">11. 高阶函数 (Higher order functions)</h2>
<p>Clojure 之所以如此强大的一个重大贡献是函数是&quot;一等公民&quot;</p>
<ul>
<li>https://en.wikipedia.org/wiki/First-class_function。</li>
</ul>
<p>它们可以是集合中的值（也可以是映射中的键），可以作为参数传递给其他函数，并作为求值结果&quot;返回&quot;。你可能从像 JavaScript 这样的语言中熟悉这个概念。</p>
<p>让我们看一下 Clojure 核心中的某些高阶函数。<code>some</code> 对集合的元素逐个调用函数，并返回第一个真值结果，如果在某个元素产生真值结果之前列表耗尽，则返回 <code>nil</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">some</span> even? [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>不要与 <code>some?</code> 混淆，它不是高阶函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">some</span> some? [<span class="hljs-literal">nil</span> <span class="hljs-literal">false</span>])
(<span class="hljs-name">some</span> some? [<span class="hljs-literal">nil</span> <span class="hljs-literal">nil</span>])
</div></code></pre>
<p>Clojure 中的一个常见惯用法是使用 <code>set</code> 作为谓词在集合中查找事物。是的，集合是函数。用作函数时，它们会在自身中查找给它们的参数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">#</span>{ <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> } <span class="hljs-string">"bar"</span>)
</div></code></pre>
<p>因此：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">some</span> #{ <span class="hljs-string">"foo"</span> } [ <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"baz"</span> ])
(<span class="hljs-name">some</span> #{ <span class="hljs-string">"fubar"</span> } [ <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"baz"</span> ])
</div></code></pre>
<p><code>apply</code> 接受一个函数和一个集合，然后在集合上&quot;应用&quot;该函数。假设你有一个数字集合，想要将它们相加。这行不通：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p><code>apply</code> 来救援：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> + [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>将数字连接为字符串：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> str [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>对比：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>我们也已经在上面看到了 <code>filter</code> 和 <code>remove</code>，这是两个非常常用的高阶函数。它们与 <code>map</code> 和 <code>reduce</code> 处于同一行列。继续阅读。😎</p>
<h2 id="12-map-%E5%92%8C-reduce">12. <code>map</code> 和 <code>reduce</code></h2>
<p>在具有头等函数的其他语言中，你可能使用过高阶函数 <code>map</code> 和 <code>reduce</code>。它们值得详细研究和练习，这里有一个超赞的预告片：
https://purelyfunctional.tv/courses/3-functional-tools/</p>
<p>让我们也在这里简要检查一下。<code>map</code> 从头到尾对一个或多个集合的元素调用函数，并返回（惰性的，稍后会更多）结果序列，顺序相同。假设我们想将列表中的每个元素减一：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> dec '(<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>))
</div></code></pre>
<p>假设我们想再次将它们减一：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> '(<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>)
     (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> dec)
     (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> dec))
</div></code></pre>
<p>嗯，也许最好减去二：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [n] (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">2</span>)) '(<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>))
</div></code></pre>
<p>如果你给 <code>map</code> 更多集合处理，它会重复：</p>
<ol>
<li>从每个集合中挑选下一个项目</li>
<li>将它们作为参数给映射函数</li>
<li>将结果添加到返回序列中
直到最短的集合耗尽：</li>
</ol>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> + [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] '(<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [n1 s n2] (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> n1 <span class="hljs-string">": "</span> s <span class="hljs-string">"-"</span> n2))
     (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>)
     [ <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"baz"</span> ]
     (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">2</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>))
</div></code></pre>
<p>（我们还没有过多讨论 <code>range</code>，它是一个生成数字序列的函数。没有参数时，它生成一个无限的，小心 😀，整数序列 0, 0+1, 0+2, 0+3, 0+4, 0+5, 0.6 ... 好在其他序列耗尽了！）</p>
<p>在其他语言中，你可能用 <code>for</code> 循环解决的许多任务，在 Clojure 中用 <code>map</code> 解决。</p>
<p>对于其他这样的&quot;for循环式&quot;任务，你将使用 <code>reduce</code>。与 <code>map</code> 不同，它不限于产生与输入集合相同长度或形状的结果。相反，它累积任何形状的结果。例如，它可以从未数字集合创建一个字符串：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [acc n]
          (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> acc <span class="hljs-string">": "</span> n))
        [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p><code>reduce</code> 将使用两个参数调用函数：上次函数调用的结果和列表中的下一个数字。过程的开始是特殊的，因为那时还没有结果。<code>reduce</code> 有两种处理方式，具体来说有两种元数。用两个参数调用时，它使用列表中的前两个元素进行第一次函数调用。这是使用 <code>reduce</code> 的两个元数版本减少 <code>+</code> 函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> + [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>过程从这样调用 <code>+</code> 开始：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>)
</div></code></pre>
<p>给 <code>reduce</code> 三个参数使其使用第二个参数作为起始&quot;结果&quot;：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> + <span class="hljs-number">100</span> [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>你可能注意到 <code>+</code> 函数接受多于（和少于）2个参数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span>)
(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>)
</div></code></pre>
<p><code>+</code> 将取第一个参数（如果有），并将其添加到&quot;当前&quot;值（为零），然后下一个参数并将其添加到新当前值，依此类推，直到有结果。这个过程听起来有点像我刚才描述的 reduce，对吧？事实上，就是这样。</p>
<p>如果我们实现 <code>+</code> 函数，我们如何做？我们可以先实现一个将两个数字相加的东西，然后用它作为减少函数与 <code>reduce</code> 一起使用。当然，现在我们有将两个数字相加的任务，而不使用现有的 <code>+</code> 函数... 🤔 SICP 有这个，使用 Peano 算术 https://youtu.be/V_7mmwpgJHU?t=814 https://en.wikipedia.org/wiki/Peano_axioms#Addition</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> plus [x y]
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> x)
    y
    (<span class="hljs-name">plus</span> (<span class="hljs-name"><span class="hljs-builtin-name">dec</span></span> x) (<span class="hljs-name"><span class="hljs-builtin-name">inc</span></span> y))))
</div></code></pre>
<p>但这里没有处理太多情况... 嗯... 让我们保持简单，只做整数数学。然后我们可以使用 Java 的 <code>Integer.sum(x, y)</code> 方法：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">Integer/sum</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>)
</div></code></pre>
<p>太棒了，有了这个，我们可以创建一个 <code>add-two</code> 函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add-two [x y]
  (<span class="hljs-name">Integer/sum</span> x y))
(<span class="hljs-name">add-two</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>)
</div></code></pre>
<p>与 <code>+</code> 不同，这个不能完全与高阶函数如 apply 组合：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-two [])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-two [<span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-two [<span class="hljs-number">1</span> <span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-two [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>我们需要 <code>add-many</code>。使用 <code>reduce</code> 和我们的 <code>add-two</code>，我们可以这样定义 <code>add-many</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add-many [&amp; numbers]
  (<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> add-two numbers))
</div></code></pre>
<p>这样就行，对吧？</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-many [<span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-many [<span class="hljs-number">1</span> <span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add-many [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>零元数版本的 <code>+</code> 呢，你问？正确，那会爆炸：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">add-many</span>)
</div></code></pre>
<p>内置的 <code>+</code> 函数有一个默认的&quot;当前&quot;值为零，记得吗？我们可以将它添加到 <code>add-many</code> 中，有两种方式：要么添加一个零元数签名，要么使用三个元数的 <code>reduce</code>。让我们选择后一种选项，因为我们正在学习关于 reduce：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add* [&amp; numbers]
  (<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> add-two <span class="hljs-number">0</span> numbers))
(<span class="hljs-name">add*</span>)
(<span class="hljs-name">add*</span> <span class="hljs-number">1</span>)
(<span class="hljs-name">add*</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>)
(<span class="hljs-name">add*</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)
</div></code></pre>
<p>BOOM.</p>
<p>我们也可以用 <code>apply</code> 使用它：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add* [])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add* [<span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add* [<span class="hljs-number">1</span> <span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> add* [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>或者 <code>reduce</code>：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> add* [])
(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> add* [<span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> add* [<span class="hljs-number">1</span> <span class="hljs-number">1</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> add* [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>除了我们只处理整数外，我们的 <code>add*</code> 非常像 Clojure 核心中 <code>+</code> 的实现方式。检查一下（在输出窗口中）：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">source</span> +)
</div></code></pre>
<p>嗯，好吧，他们似乎在低元数情况下使用多元数函数签名，可能是因为类型转换，但无论如何，😀</p>
<p>关于 <code>reduce</code> 还有一件事要提。编写减少函数时，你可以在输入序列耗尽之前停止该过程，使用 <code>reduced</code> 函数。假设我们想要输入序列作为一个由 <code>:</code> 分隔的字符串，但在看到 <code>nil</code> 项时停止。这是最后一个版本作为比较：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [acc n]
          (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> acc <span class="hljs-string">": "</span> n))
        [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-literal">nil</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>我们可以通过在遇到 <code>nil</code> 项时用累积值调用 <code>reduced</code> 来短路这个过程：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [acc n]
          (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">nil?</span></span> n)
            (<span class="hljs-name"><span class="hljs-builtin-name">reduced</span></span> acc)
            (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> acc <span class="hljs-string">": "</span> n)))
        [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-literal">nil</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span>])
</div></code></pre>
<p>这是发生的事情：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">doc</span> reduced)
</div></code></pre>
<p>减少是 Clojure 中一个非常重要的概念，因为它是一种&quot;函数优先&quot;的语言。或者正如 Functional Design 节目中所说的 https://clojuredesign.club/episode/058-reducing-it-down/ &quot;减少函数是函数式编程的支柱，因为我们没有变异。&quot;</p>
<p>事实上，在 Clojure 中减少是如此重要，Rich Hickey 添加了一个包含更多功能的 reducers 库 https://clojure.org/reference/reducers</p>
<p>Functional Design 二人组，Nate Jones 和 Christoph Neumann 也检查了这个库：https://clojuredesign.club/episode/060-reduce-done-quick/</p>
<p>该集中的精彩引用：&quot;序列抽象，它相当惰性。&quot;</p>
<p>我们不会深入 reducers 库的兔子洞...</p>
<h2 id="13-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7-immutability">13. 不可变性 (Immutability)</h2>
<p>相当疯狂的是，我们已经讨论 Clojure 这么久了，还没有讨论它如何鼓励我们在处理数据时不改变数据。Clojurians 从不停止谈论不可变性，对吧？我们有时听起来像 Rothbardians，定义自己为 State 的敌人 😄 https://www.youtube.com/watch?v=qe60zwUAOqE</p>
<p>在某种程度上这是真的，作为 Clojurians，我们经常尝试在操作持续期间保持在数据转换模式中，只在&quot;边界&quot;处理不纯世界，开始时我们可能在读取一些输入，结束时我们可能在更新数据库，将结果打印到文件（或屏幕），或改变网页的 DOM。</p>
<p>Clojure 通过多种方式鼓励我们走在不可变的道路上，我将在这里提到其中两种：</p>
<ul>
<li>持久数据结构 (Persistent Data Structures)</li>
<li>纯函数 (Pure Functions)</li>
</ul>
<h3 id="%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-persistent-data-structures">持久数据结构 (Persistent Data Structures)</h3>
<p>Clojure 通过为我们提供不可变数据结构来帮助我们保持在不可变领域。这些的实现称为持久数据结构：https://en.wikipedia.org/wiki/Persistent_data_structure 实际上，这意味着数据结构永远不会改变，我们用于转换它们的函数实际上创建了副本。（以非常聪明的方式，所以现在不要开始担心。）</p>
<p>假设我们定义了一个包含一些数字的向量：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> eighteen [<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>])
eighteen
</div></code></pre>
<p>现在我们想将最后一个 <code>0</code> 更改为 <code>1</code>。我们可以使用 <code>assoc</code> 函数。在向量上使用时，它接受一个索引和新值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> nineteen (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> eighteen <span class="hljs-number">4</span> <span class="hljs-number">1</span>))
nineteen
</div></code></pre>
<p>再次检查 <code>eighteen</code>...</p>
<pre class="hljs"><code><div>eighteen
</div></code></pre>
<p>...我们看到它仍然忠于它的名字。在索引4处将 <code>1</code> 关联到它创建了一个副本，然后定义为 <code>nineteen</code>。</p>
<p>这在局部绑定中也是正确的：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [origin {<span class="hljs-symbol">:x</span> <span class="hljs-number">0</span>
              <span class="hljs-symbol">:y</span> <span class="hljs-number">0</span>}
      x-travel (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> origin <span class="hljs-symbol">:x</span> <span class="hljs-number">100</span>)]
  [origin x-travel])
</div></code></pre>
<p>这提供了非常确定性的程序流程。数据不会在我们脚下随意改变。不改变状态的转换过程更容易并行化，其他线程无法改变你正在转换的数据。一整类 bug 永远没有机会孵化！</p>
<p>不可变性带来的另一个好处是 Clojure 可以有效地提供值相等性。值根据定义是不可变的。在 Clojure 中，即使是最深的数据结构也可以在不到一瞬间内进行比较。</p>
<p>让我们用一个不太深的结构展示这一点（除了名称）：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> universa {<span class="hljs-symbol">:one</span> {<span class="hljs-string">"Alice"</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">100</span>
                              <span class="hljs-symbol">:y</span> <span class="hljs-number">100</span>
                              <span class="hljs-symbol">:z</span> <span class="hljs-number">100</span>}
                    <span class="hljs-string">"Bob"</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">100</span>
                          <span class="hljs-symbol">:y</span> <span class="hljs-number">100</span>
                          <span class="hljs-symbol">:z</span> <span class="hljs-number">100</span>}}
               <span class="hljs-symbol">:two</span> {<span class="hljs-string">"Alice"</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">100</span>
                              <span class="hljs-symbol">:y</span> <span class="hljs-number">100</span>
                              <span class="hljs-symbol">:z</span> <span class="hljs-number">100</span>}
                    <span class="hljs-string">"Bob"</span> {<span class="hljs-symbol">:x</span> <span class="hljs-number">100</span>
                          <span class="hljs-symbol">:y</span> <span class="hljs-number">100</span>
                          <span class="hljs-symbol">:z</span> <span class="hljs-number">99</span>}}})

(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-symbol">:one</span> universa)
   (<span class="hljs-symbol">:two</span> universa))
</div></code></pre>
<p><code>update-in</code> 是一个用于转换数据结构的高阶函数，给定一个&quot;地址&quot;和一个函数。我们可以用它来让两个-Bob 找到两个-Alice，就像一-Bob 和一-Alice 已经找到彼此一样：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> unified-universa
  (<span class="hljs-name"><span class="hljs-builtin-name">update-in</span></span> universa [<span class="hljs-symbol">:two</span> <span class="hljs-string">"Bob"</span> <span class="hljs-symbol">:z</span>] inc))
unified-universa

(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-symbol">:one</span> unified-universa)
   (<span class="hljs-symbol">:two</span> unified-universa))

(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> universa unified-universa)
</div></code></pre>
<p>你永远不必再编写 <code>equals()</code> 方法！😄</p>
<p>不可变性也使我们的程序与你可以随意改变变量值时不同。可能需要一段时间来习惯这一点。（我仍然处于更容易看到许多问题的变异解决方案的阶段。这种情况越来越少，但无论如何。可能你会比我更快掌握它。）</p>
<p>坚持理解它是绝对值得的。回报是巨大的。如果你只打算查看我在本指南中推荐的资源之一，我建议是 Rafal Dittwald 关于以 Clojure 方式解决问题的这个：https://www.youtube.com/watch?v=vK1DazRK_a0 剧透：他在视频中没有使用 Clojure</p>
<p>当然，在谈话中，Rafal 不仅假装数据是不可变的。他还使用了函数纯度。</p>
<h3 id="%E7%BA%AF%E5%87%BD%E6%95%B0-pure-functions">纯函数 (Pure Functions)</h3>
<p>Clojure 不像某些语言那样强制纯度（看着你 Haskell），但它使养成编写纯函数的习惯变得容易，从而将副作用推向程序的&quot;边缘&quot;。</p>
<p>如果函数遵守以下规则，则被认为是纯的：</p>
<ol>
<li>对于相同的输入，始终返回相同的值</li>
<li>不影响其环境中的任何内容。因此，不改变任何东西，包括不打印任何内容到任何地方，或命中改变 API 端点。</li>
</ol>
<p>纯函数是确定性的，你可以安全地调用它，不用担心它会更新应用程序状态或做任何其他事情，只计算基于你给它的输入的返回值，仅此而已。</p>
<h2 id="14-%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-transforming-data-structures">14. 转换数据结构 (Transforming Data Structures)</h2>
<p>Clojure 有一个核心库，使&quot;深入&quot;数据结构并操作它变得容易，有趣且可读，创建一个带有结果的副本。</p>
<p>我们已经看到了 <code>assoc</code>，它创建了数据结构的副本，在索引（对于 <code>vector</code>）或键（对于映射）处有新值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> colt-express
  {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Colt Express"</span>
   <span class="hljs-symbol">:categories</span> [<span class="hljs-string">"Family"</span>
                <span class="hljs-string">"Strategy"</span>]
   <span class="hljs-symbol">:play-time</span> <span class="hljs-number">40</span>
   <span class="hljs-symbol">:ratings</span> {<span class="hljs-symbol">:pez</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:kat</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:wiv</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:vig</span> <span class="hljs-number">3</span>
             <span class="hljs-symbol">:rex</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:lun</span> <span class="hljs-number">4</span>}})

(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> exit-haunted
  {<span class="hljs-symbol">:name</span> <span class="hljs-string">"EXIT: The Haunted Roller Coaster"</span>
   <span class="hljs-symbol">:categories</span> [<span class="hljs-string">"Family"</span>
                <span class="hljs-string">"Co-op"</span>
                <span class="hljs-string">"Puzzle"</span>
                <span class="hljs-string">"Cards"</span>]
   <span class="hljs-symbol">:ratings</span> {<span class="hljs-symbol">:pez</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:kat</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:wiv</span> <span class="hljs-number">5</span>
             <span class="hljs-symbol">:vig</span> <span class="hljs-number">4</span>
             <span class="hljs-symbol">:rex</span> <span class="hljs-number">5</span>}})
</div></code></pre>
<p><code>assoc</code> 可以向映射添加新键：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> colt-express-w-age
  (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> colt-express <span class="hljs-symbol">:age-from</span> <span class="hljs-number">10</span>))
</div></code></pre>
<p>对于向量，你只能在最后一项后面添加新项，不能超出：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> board-games-empty
  [])

(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> board-games-w-c-e
  (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> board-games-empty <span class="hljs-number">0</span> colt-express))
</div></code></pre>
<p><code>board-games-empty</code> 仍然是空的。因此：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> board-games-w-c-e-and-exit-fail
  (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> board-games-empty <span class="hljs-number">1</span> exit-haunted))

(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> board-games-w-c-e-and-exit
  (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> board-games-w-c-e <span class="hljs-number">1</span> exit-haunted))
</div></code></pre>
<p>使用 <code>assoc</code> 向向量添加内容并不常见。对于这个，<code>conj</code> 通常更有意义：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> board-games-empty colt-express exit-haunted)
</div></code></pre>
<p>映射上的 <code>assoc</code> 可以替换现有值（在副本中）：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> colt-express-w-age-and-adjusted-playtime
  (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> colt-express-w-age <span class="hljs-symbol">:play-time</span> <span class="hljs-number">45</span>))
</div></code></pre>
<p>向量上的 <code>assoc</code> 也可以做到这一点：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> board-games-w-adjusted-c-e
  (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> board-games-w-c-e
         <span class="hljs-number">0</span>
         colt-express-w-age-and-adjusted-playtime))
</div></code></pre>
<p>你可以在一次调用中 <code>assoc</code> 多个内容：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> colt-express
       <span class="hljs-symbol">:play-time</span> <span class="hljs-number">50</span>
       <span class="hljs-symbol">:age-from</span> <span class="hljs-number">10</span>)

(<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> board-games-empty
       <span class="hljs-number">0</span> colt-express
       <span class="hljs-number">1</span> exit-haunted)
</div></code></pre>
<p>（再次，有 <code>conj</code> 用于此。）</p>
<p>对于映射，还有 <code>merge</code>，让你合并两个或多个映射：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">merge</span></span> colt-express
       {<span class="hljs-symbol">:play-time</span> <span class="hljs-number">45</span>
        <span class="hljs-symbol">:age-from</span> <span class="hljs-number">10</span>})
</div></code></pre>
<p>注意：它是&quot;浅&quot;合并，所以像这样添加家庭成员评级不会起作用：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">merge</span></span> exit-haunted
       {<span class="hljs-symbol">:play-time</span> <span class="hljs-number">90</span>
        <span class="hljs-symbol">:ratings</span> {<span class="hljs-symbol">:lun</span> <span class="hljs-number">5</span>}
        <span class="hljs-symbol">:age-from</span> <span class="hljs-number">10</span>})
</div></code></pre>
<p><code>assoc</code> 做同样的事情：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> exit-haunted <span class="hljs-symbol">:ratings</span> {<span class="hljs-symbol">:lun</span> <span class="hljs-number">5</span>})
</div></code></pre>
<p>Clojure 核心中没有深合并，但有 <code>assoc-in</code> 用于深入访问。它不接受键（或索引），而是接受一个&quot;路径&quot;：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">assoc-in</span> exit-haunted [<span class="hljs-symbol">:ratings</span> <span class="hljs-symbol">:lun</span>] <span class="hljs-number">5</span>)

(<span class="hljs-name">assoc-in</span> colt-express [<span class="hljs-symbol">:categories</span> <span class="hljs-number">2</span>] <span class="hljs-string">"Planning"</span>)
<span class="hljs-comment">;;（但...不要这样做，参见下面的 `update`，了解如何 `conj` 类别。）</span>
</div></code></pre>
<p>与 <code>assoc</code> 不同，你一次只能用 <code>assoc-in</code> 添加一个东西。</p>
<p>使用 <code>dissoc</code> 从映射中删除内容：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">dissoc</span></span> colt-express <span class="hljs-symbol">:play-time</span> <span class="hljs-symbol">:ratings</span> <span class="hljs-symbol">:categories</span>)
</div></code></pre>
<p>你可能会经常在 REPL（像你在这个文件中这样）中使用 <code>dissoc</code>，来检查可能包含一些大数据结构的数据结构，比如日志或其他：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">dissoc</span></span> colt-express <span class="hljs-symbol">:log</span>)
</div></code></pre>
<p>（这个数据结构没有任何日志，所以它保持不变，但无论如何。）</p>
<p>Clojure 核心中没有 <code>dissoc-in</code>，但在访问 <code>update</code> 和 <code>update-in</code> 之后，让我们回到这个话题。</p>
<p><code>update</code> 和 <code>update-in</code> 与它们的 <code>assoc</code> 对应物类似，但不是值，它们接受一个用于操作值的函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">update</span> exit-haunted <span class="hljs-symbol">:name</span> string/upper-case)
</div></code></pre>
<p>练习：将 <code>colt-express</code> 条目的 <code>:play-time</code> 更新为 5 或左右。</p>
<p>你添加到函数后的参数会传递给函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name">update</span> colt-express <span class="hljs-symbol">:categories</span> conj <span class="hljs-string">"Planning"</span>)
</div></code></pre>
<p>练习：使你对 <code>:play-time</code> 的更新将 <code>5</code>（或左右）作为参数。</p>
<p>练习：从 <code>exit-haunted</code> 的 <code>:ratings</code> 中移除 <code>:pez</code> 和 <code>:wiv</code> 条目。</p>
<p><code>update-in</code> 是 <code>assoc-in</code> 的对应物，就像 <code>update</code> 是 <code>assoc</code> 的对应物：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">update-in</span></span> colt-express [<span class="hljs-symbol">:ratings</span> <span class="hljs-symbol">:lun</span>] inc)

(<span class="hljs-name"><span class="hljs-builtin-name">update-in</span></span> colt-express [<span class="hljs-symbol">:ratings</span> <span class="hljs-symbol">:lun</span>] + <span class="hljs-number">9000</span>)
<span class="hljs-comment">;; https://www.youtube.com/watch?v=PCHxU7witPA</span>
</div></code></pre>
<p>练习：没有 <code>dissoc-in</code>，但它看起来你可以使用 <code>update-in</code> 来做到这一点，不是吗？</p>
<p>奖励是你在缺少 <code>dissoc-in</code> 时可以少访问一次 StackOverflow 😄
https://stackoverflow.com/a/21942548/44639</p>
<p>我们之前已经使用关键字作为映射查找函数。这很好，但有时你可能更喜欢 <code>get</code> 函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> colt-express <span class="hljs-symbol">:ratings</span>)

(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-symbol">:ratings</span> colt-express)
   (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> colt-express <span class="hljs-symbol">:ratings</span>))
</div></code></pre>
<p><code>get</code> 接受第三个参数，如果条目缺失，将用作默认值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> exit-haunted <span class="hljs-symbol">:play-time</span> <span class="hljs-number">0</span>)
</div></code></pre>
<p>关键字作为查找函数也支持这一点：</p>
<pre class="hljs"><code><div>(<span class="hljs-symbol">:play-time</span> exit-haunted <span class="hljs-number">0</span>)
</div></code></pre>
<p>没有默认值，将返回 <code>nil</code>。这可能会爆炸，取决于你用这个值做什么：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> colt-express <span class="hljs-symbol">:play-time</span>) <span class="hljs-number">2</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> exit-haunted <span class="hljs-symbol">:play-time</span>) <span class="hljs-number">2</span>)
</div></code></pre>
<p>在这种情况下，安全总比后悔好：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> colt-express <span class="hljs-symbol">:play-time</span> <span class="hljs-number">0</span>) <span class="hljs-number">2</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> exit-haunted <span class="hljs-symbol">:play-time</span> <span class="hljs-number">0</span>) <span class="hljs-number">2</span>)
</div></code></pre>
<p>是的，也有 <code>get-in</code>。练习：使用 <code>get-in</code> 获取我对这两个精彩家庭游戏的评级。</p>
<p>你可能已经注意到，本节中的所有函数都将集合作为第一个参数。这使得它们很容易与线程第一 <code>-&gt;</code> 宏一起使用。这是设计使然，是高度惯用的 Clojure。</p>
<p>通常会看到像这样的数据转换管道：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">-&gt;</span></span> exit-haunted
    (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> <span class="hljs-symbol">:play-time</span> <span class="hljs-number">90</span>)
    (<span class="hljs-name">update</span> <span class="hljs-symbol">:categories</span> conj <span class="hljs-string">"Scary"</span>)
    (<span class="hljs-name">assoc-in</span> [<span class="hljs-symbol">:ratings</span> <span class="hljs-symbol">:lun</span>] <span class="hljs-number">5</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">update-in</span></span> [<span class="hljs-symbol">:ratings</span> <span class="hljs-symbol">:vig</span>] + <span class="hljs-number">1</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">dissoc</span></span> <span class="hljs-symbol">:name</span>)
    (<span class="hljs-name">update</span> <span class="hljs-symbol">:log</span> vec)
    (<span class="hljs-name">update</span> <span class="hljs-symbol">:log</span> conj <span class="hljs-string">"Name redacted"</span>)
    (<span class="hljs-name">update</span> <span class="hljs-symbol">:log</span> conj <span class="hljs-string">"(Because scary)"</span>))
</div></code></pre>
<p>（尽管，可能比这更有意义。）</p>
<p>我推荐在 ClojureDocs 上&quot;另请参阅&quot;浏览一些从这里开始的内容：
https://clojuredocs.org/clojure.core/update-in
并将很多示例粘贴到这里进行实验。</p>
<h2 id="15-%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88-manipulating-sets">15. 操作集合 (Manipulating Sets)</h2>
<p>(下面的部分由Qwen llm续写生成)</p>
<p>集合（Sets）是 Clojure 中四种核心集合类型之一，具有两个关键特性：<strong>唯一性</strong>（没有重复元素）和<strong>无序性</strong>（不保证元素顺序）。</p>
<p>集合字面量使用 <code>#{}</code> 语法：</p>
<pre class="hljs"><code><div>#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>}
#{<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:b</span> <span class="hljs-symbol">:c</span>}
#{}
</div></code></pre>
<h3 id="%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">集合的基本操作</h3>
<h4 id="%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88">创建集合</h4>
<pre class="hljs"><code><div><span class="hljs-comment">;; 从字面量</span>
#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>}

<span class="hljs-comment">;; 从其他集合转换</span>
(<span class="hljs-name">set</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>])  <span class="hljs-comment">; =&gt; #{1 2 3}</span>
(<span class="hljs-name">set</span> <span class="hljs-string">"hello"</span>)       <span class="hljs-comment">; =&gt; #{\h \e \l \o}</span>

<span class="hljs-comment">;; 创建空集合</span>
#{}
(<span class="hljs-name"><span class="hljs-builtin-name">hash-set</span></span>)
(<span class="hljs-name"><span class="hljs-builtin-name">sorted-set</span></span>)
</div></code></pre>
<h3 id="%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">添加和删除元素</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 添加元素 - conj 用于添加</span>
(<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">4</span>)   <span class="hljs-comment">; =&gt; #{1 2 3 4}</span>
(<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">2</span>)   <span class="hljs-comment">; =&gt; #{1 2 3} (重复元素被忽略)</span>

<span class="hljs-comment">;; 删除元素 - disj 用于删除</span>
(<span class="hljs-name"><span class="hljs-builtin-name">disj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">2</span>)   <span class="hljs-comment">; =&gt; #{1 3}</span>
(<span class="hljs-name"><span class="hljs-builtin-name">disj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">4</span>)   <span class="hljs-comment">; =&gt; #{1 2 3} (不存在的元素被忽略)</span>
</div></code></pre>
<h3 id="%E6%A3%80%E6%9F%A5%E6%88%90%E5%91%98%E5%85%B3%E7%B3%BB">检查成员关系</h3>
<p>集合在 Clojure 中同时也是函数，这使得成员检查非常简洁：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 作为函数调用</span>
(<span class="hljs-name">#</span>{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">2</span>)   <span class="hljs-comment">; =&gt; 2 (如果元素存在，返回该元素)</span>
(<span class="hljs-name">#</span>{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">4</span>)   <span class="hljs-comment">; =&gt; nil (如果元素不存在，返回 nil)</span>

<span class="hljs-comment">;; 使用 contains? 函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">contains?</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">2</span>)  <span class="hljs-comment">; =&gt; true</span>
(<span class="hljs-name"><span class="hljs-builtin-name">contains?</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">4</span>)  <span class="hljs-comment">; =&gt; false</span>

<span class="hljs-comment">;; 使用 some 函数检查多个值</span>
(<span class="hljs-name">some</span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>])  <span class="hljs-comment">; =&gt; 2 (返回第一个在集合中存在的元素)</span>
</div></code></pre>
<h2 id="%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">集合运算</h2>
<p>Clojure 提供了完整的集合运算支持，让集合操作变得直观而强大：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> odds #{<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>})
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> evens #{<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span>})
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> primes #{<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span>})

<span class="hljs-comment">;; 并集 (union)</span>
(<span class="hljs-name">clojure.set/union</span> odds evens)  <span class="hljs-comment">; =&gt; #{0 1 2 3 4 5 6 7 8 9}</span>

<span class="hljs-comment">;; 交集 (intersection)</span>
(<span class="hljs-name">clojure.set/intersection</span> odds primes)  <span class="hljs-comment">; =&gt; #{3 5 7}</span>

<span class="hljs-comment">;; 差集 (difference)</span>
(<span class="hljs-name">clojure.set/difference</span> odds primes)  <span class="hljs-comment">; =&gt; #{1 9}</span>
(<span class="hljs-name">clojure.set/difference</span> primes odds) <span class="hljs-comment">; =&gt; #{2 11}</span>

<span class="hljs-comment">;; 对称差集 (可以用 union 和 difference 组合)</span>
(<span class="hljs-name">clojure.set/union</span> 
  (<span class="hljs-name">clojure.set/difference</span> odds primes)
  (<span class="hljs-name">clojure.set/difference</span> primes odds))  <span class="hljs-comment">; =&gt; #{1 2 9 11}</span>

<span class="hljs-comment">;; 子集关系</span>
(<span class="hljs-name">clojure.set/subset?</span> #{<span class="hljs-number">1</span> <span class="hljs-number">3</span>} #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>})  <span class="hljs-comment">; =&gt; true</span>
(<span class="hljs-name">clojure.set/superset?</span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>} #{<span class="hljs-number">1</span> <span class="hljs-number">3</span>})  <span class="hljs-comment">; =&gt; true</span>
</div></code></pre>
<h2 id="%E9%9B%86%E5%90%88%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">集合与高阶函数</h2>
<p>集合可以与所有 Clojure 高阶函数配合使用，让数据处理更加灵活：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 使用 map 转换集合</span>
(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> inc #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>})  <span class="hljs-comment">; =&gt; (2 3 4) 注意: 返回的是序列，不是集合</span>

<span class="hljs-comment">;; 但可以转换回集合</span>
(<span class="hljs-name">set</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> inc #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>}))  <span class="hljs-comment">; =&gt; #{2 3 4}</span>

<span class="hljs-comment">;; 使用 filter 过滤</span>
(<span class="hljs-name">set</span> (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even? #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>}))  <span class="hljs-comment">; =&gt; #{2 4}</span>

<span class="hljs-comment">;; 使用 reduce 聚合</span>
(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> + #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>})  <span class="hljs-comment">; =&gt; 15</span>
</div></code></pre>
<h2 id="%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%A8%E4%BE%8B">集合的实际用例</h2>
<p>在实际程序中，集合有多种常见用途：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 1. 去重</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> users [<span class="hljs-string">"Alice"</span> <span class="hljs-string">"Bob"</span> <span class="hljs-string">"Charlie"</span> <span class="hljs-string">"Alice"</span> <span class="hljs-string">"Diana"</span>])
(<span class="hljs-name">distinct</span> users)  <span class="hljs-comment">; =&gt; ("Alice" "Bob" "Charlie" "Diana")</span>
(<span class="hljs-name">set</span> users)       <span class="hljs-comment">; =&gt; #{"Diana" "Charlie" "Bob" "Alice"}</span>

<span class="hljs-comment">;; 2. 快速查找</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> valid-codes #{<span class="hljs-symbol">:active</span> <span class="hljs-symbol">:inactive</span> <span class="hljs-symbol">:suspended</span> <span class="hljs-symbol">:deleted</span>})
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> user-status <span class="hljs-symbol">:active</span>)

(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">valid-codes</span> user-status)
  (<span class="hljs-name">println</span> <span class="hljs-string">"Valid status"</span>) 
  (<span class="hljs-name">println</span> <span class="hljs-string">"Invalid status"</span>))

<span class="hljs-comment">;; 3. 多选标签处理</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> document-tags #{<span class="hljs-string">"clojure"</span> <span class="hljs-string">"functional"</span> <span class="hljs-string">"immutable"</span>})
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> search-tags #{<span class="hljs-string">"clojure"</span> <span class="hljs-string">"data"</span>})

<span class="hljs-comment">;; 查找同时包含所有搜索标签的文档</span>
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">clojure.set/subset?</span> search-tags document-tags)
  (<span class="hljs-name">println</span> <span class="hljs-string">"Document matches all tags"</span>)
  (<span class="hljs-name">println</span> <span class="hljs-string">"Document does not match all tags"</span>))

<span class="hljs-comment">;; 4. 图算法中的节点集合</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> graph {<span class="hljs-symbol">:a</span> #{<span class="hljs-symbol">:b</span> <span class="hljs-symbol">:c</span>}
            <span class="hljs-symbol">:b</span> #{<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:d</span>}
            <span class="hljs-symbol">:c</span> #{<span class="hljs-symbol">:a</span>}
            <span class="hljs-symbol">:d</span> #{<span class="hljs-symbol">:b</span>}})
</div></code></pre>
<h2 id="%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">集合类型</h2>
<p>Clojure 有两种主要的集合实现：</p>
<ol>
<li>
<p><strong>哈希集合 (Hash Sets)</strong></p>
<ul>
<li>默认的集合类型</li>
<li>无序</li>
<li>基于哈希表实现</li>
<li>O(1) 的查找、添加和删除操作</li>
</ul>
</li>
<li>
<p><strong>排序集合 (Sorted Sets)</strong></p>
<ul>
<li>保持元素排序</li>
<li>基于红黑树实现</li>
<li>O(log n) 的查找、添加和删除操作</li>
<li>需要元素实现 Comparable 接口</li>
</ul>
</li>
</ol>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> hash-set-example #{<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span>})
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> sorted-set-example (<span class="hljs-name"><span class="hljs-builtin-name">sorted-set</span></span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span>))

hash-set-example     <span class="hljs-comment">; =&gt; #{1 4 3 2 5} (顺序不确定)</span>
sorted-set-example   <span class="hljs-comment">; =&gt; #{1 2 3 4 5} (按顺序)</span>
</div></code></pre>
<h2 id="%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">选择正确的集合类型</h2>
<p>当选择使用哪种集合类型时，考虑以下因素：</p>
<ul>
<li><strong>需要唯一性但不关心顺序</strong>：使用标准集合 <code>#{}</code></li>
<li><strong>需要唯一性且关心顺序</strong>：使用排序集合 <code>(sorted-set)</code></li>
<li><strong>需要保留重复元素</strong>：使用向量 <code>[]</code> 或列表 <code>'()</code></li>
<li><strong>需要键值对</strong>：使用映射 <code>{}</code></li>
<li><strong>需要快速在末尾添加元素</strong>：使用向量</li>
<li><strong>需要快速在开头添加元素</strong>：使用列表</li>
</ul>
<p>集合是 Clojure 处理唯一元素集合的理想选择，配合 Clojure 强大的函数式工具，能让数据处理代码变得简洁而富有表达力。</p>
<h2 id="%E7%BB%83%E4%B9%A0">练习</h2>
<ol>
<li>
<p>给定两个集合 <code>#{1 2 3 4}</code> 和 <code>#{3 4 5 6}</code>，找出它们的并集、交集和差集。</p>
</li>
<li>
<p>编写一个函数，接收一个整数集合，返回其中的所有偶数。</p>
</li>
<li>
<p>创建一个包含 1 到 100 中所有素数的集合。</p>
</li>
<li>
<p>给定一个字符串集合，找出所有长度大于 5 的字符串。</p>
</li>
<li>
<p>编写一个函数，检查一个集合是否是另一个集合的子集。</p>
</li>
</ol>
<p>接下来，让我们探索 Clojure 的元数据（Metadata）系统，这是 Clojure 中一个强大但常被忽视的特性。</p>
<h1 id="16-%E5%85%83%E6%95%B0%E6%8D%AE-metadata">16. 元数据 (Metadata)</h1>
<p>元数据是附加到对象上的额外信息，不影响对象的值相等性，但可以在运行时访问。这类似于对象的注释或标签，不会改变对象的核心行为，但可以为工具、编译器或运行时系统提供额外信息。</p>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E6%95%B0%E6%8D%AE">什么是元数据？</h2>
<p>在 Clojure 中，元数据是存储在对象上的键值对映射。它不会影响对象的值：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-comment">^{:debug true}</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])  <span class="hljs-comment">; =&gt; true</span>
</div></code></pre>
<p>这里 <code>^{:debug true}</code> 是附加到向量的元数据，但两个向量在值上仍然相等。</p>
<h2 id="%E9%99%84%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE">附加元数据</h2>
<p>有两种方式附加元数据：</p>
<ol>
<li><strong>使用 <code>with-meta</code> 函数</strong>：</li>
</ol>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">with-meta</span></span> [<span class="hljs-symbol">:a</span> <span class="hljs-symbol">:b</span> <span class="hljs-symbol">:c</span>] {<span class="hljs-symbol">:source</span> <span class="hljs-string">"database"</span> <span class="hljs-symbol">:version</span> <span class="hljs-number">1</span>})
</div></code></pre>
<ol start="2">
<li><strong>使用元数据读取器宏</strong>（<code>^</code> 前缀）：</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">^{:debug true}</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
^<span class="hljs-symbol">:debug</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]  <span class="hljs-comment">; 短语法，等同于 ^{:debug true}</span>
<span class="hljs-comment">^{:doc "函数文档"}</span> (<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> my-func [])  <span class="hljs-comment">; 附加到函数</span>
</div></code></pre>
<h2 id="%E8%AF%BB%E5%8F%96%E5%85%83%E6%95%B0%E6%8D%AE">读取元数据</h2>
<p>使用 <code>meta</code> 函数读取对象的元数据：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> data <span class="hljs-comment">^{:debug true}</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])
(<span class="hljs-name"><span class="hljs-builtin-name">meta</span></span> data)  <span class="hljs-comment">; =&gt; {:debug true}</span>
</div></code></pre>
<h2 id="%E5%B8%B8%E8%A7%81%E5%85%83%E6%95%B0%E6%8D%AE%E7%94%A8%E9%80%94">常见元数据用途</h2>
<h3 id="1-%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3">1. 函数文档</h3>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> <span class="hljs-comment">^{:doc "添加两个数字"}</span> add [a b] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))
(<span class="hljs-name">doc</span> add)  <span class="hljs-comment">; 显示文档</span>
</div></code></pre>
<h3 id="2-%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA-type-hints">2. 类型提示 (Type Hints)</h3>
<p>Clojure 是动态类型语言，但有时提供类型提示可以避免反射，提高性能：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> <span class="hljs-comment">^String</span> capitalize [<span class="hljs-comment">^String</span> s] 
  (<span class="hljs-name">.toUpperCase</span> s))
</div></code></pre>
<h3 id="3-%E6%A0%87%E8%AE%B0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7">3. 标记函数特性</h3>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> ^<span class="hljs-symbol">:private</span> helper-function [x] (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> x <span class="hljs-number">2</span>))  <span class="hljs-comment">; 标记为私有</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> ^<span class="hljs-symbol">:dynamic</span> *context* [] (<span class="hljs-name">get-context</span>))   <span class="hljs-comment">; 标记为动态变量</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> ^<span class="hljs-symbol">:const</span> pi [] <span class="hljs-number">3.14159</span>)                  <span class="hljs-comment">; 标记为常量</span>
</div></code></pre>
<h3 id="4-%E6%B5%8B%E8%AF%95%E5%85%83%E6%95%B0%E6%8D%AE">4. 测试元数据</h3>
<p>正如之前在 FizzBuzz 示例中看到的，可以将测试附加到函数：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> <span class="hljs-comment">^{:test (fn [] (assert (= (inc 1) 2)))}</span> increment [x] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x <span class="hljs-number">1</span>))
</div></code></pre>
<h2 id="%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">元数据的实际应用</h2>
<p>元数据让 Clojure 代码更加自描述，同时不牺牲性能和灵活性。让我们看一个实际例子：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 定义一个带有元数据的函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> <span class="hljs-comment">^{:doc "安全获取映射中的值，如果键不存在则返回默认值"
         :added "1.0"
         :static true}</span>
  safe-get
  [m k default]
  (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> m k default))

<span class="hljs-comment">;; 在REPL中查看文档</span>
(<span class="hljs-name">doc</span> safe-get)

<span class="hljs-comment">;; 使用 clojure.repl/source 查看源码和元数据</span>
(<span class="hljs-name">source</span> safe-get)
</div></code></pre>
<p>元数据也广泛用于 Web 框架和库中，例如 Ring 中间件使用元数据标记处理函数的特性：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> <span class="hljs-comment">^{:ring/middleware true}</span> wrap-logging [handler]
  (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [request]
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [response (<span class="hljs-name">handler</span> request)]
      (<span class="hljs-name">log</span> request response)
      response)))
</div></code></pre>
<h2 id="%E7%BB%83%E4%B9%A0">练习</h2>
<ol>
<li>
<p>为一个函数添加文档元数据，然后使用 <code>(doc your-function)</code> 查看。</p>
</li>
<li>
<p>为一个集合添加自定义元数据（如 <code>{:author &quot;your-name&quot;}</code>），然后使用 <code>(meta your-collection)</code> 读取它。</p>
</li>
<li>
<p>创建一个标记为 <code>^:private</code> 的函数，尝试从另一个命名空间调用它，观察结果。</p>
</li>
<li>
<p>了解 <code>^:dynamic</code> 元数据的作用，创建一个动态变量并使用 <code>binding</code> 临时重新绑定它。</p>
</li>
</ol>
<p>元数据是 Clojure 强大表达能力的重要组成部分，它让你的代码不仅仅是执行逻辑，还能携带丰富的上下文信息，使工具、库和框架能够更好地理解和使用你的代码。</p>
<h1 id="17-%E8%A7%A3%E6%9E%84-destructuring">17. 解构 (Destructuring)</h1>
<p>解构是 Clojure 中一个强大的特性，允许你在函数参数或 <code>let</code> 绑定中，直接从数据结构中提取值并绑定到局部变量。这使得代码更加简洁、清晰，减少了对辅助函数的需求。</p>
<h2 id="%E5%9F%BA%E6%9C%AC%E8%A7%A3%E6%9E%84%E8%AF%AD%E6%B3%95">基本解构语法</h2>
<p>解构使用与数据结构相似的模式来提取值：</p>
<h3 id="%E5%90%91%E9%87%8F%E8%A7%A3%E6%9E%84">向量解构</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 基本向量解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [[a b c] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b c))  <span class="hljs-comment">; =&gt; 6</span>

<span class="hljs-comment">;; 从向量提取前几个元素，其余放入剩余参数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [[x y &amp; rest] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]]
  [x y rest]) <span class="hljs-comment">; =&gt; [1 2 (3 4 5)]</span>

<span class="hljs-comment">;; 使用 :as 保留原始结构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [[x y <span class="hljs-symbol">:as</span> all] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]]
  [x y all])  <span class="hljs-comment">; =&gt; [1 2 [1 2 3 4 5]]</span>
</div></code></pre>
<h3 id="%E6%98%A0%E5%B0%84%E8%A7%A3%E6%9E%84">映射解构</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 基本映射解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{a <span class="hljs-symbol">:a</span> b <span class="hljs-symbol">:b</span>} {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span> <span class="hljs-symbol">:c</span> <span class="hljs-number">3</span>}]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))  <span class="hljs-comment">; =&gt; 3</span>

<span class="hljs-comment">;; 使用 :keys 简化关键字映射解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:keys</span> [a b]} {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span> <span class="hljs-symbol">:c</span> <span class="hljs-number">3</span>}]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))  <span class="hljs-comment">; =&gt; 3</span>

<span class="hljs-comment">;; 使用 :strs 处理字符串键</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:strs</span> [a b]} {<span class="hljs-string">"a"</span> <span class="hljs-number">1</span> <span class="hljs-string">"b"</span> <span class="hljs-number">2</span> <span class="hljs-string">"c"</span> <span class="hljs-number">3</span>}]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))  <span class="hljs-comment">; =&gt; 3</span>

<span class="hljs-comment">;; 使用 :syms 处理符号键</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:syms</span> [a b]} {'a <span class="hljs-number">1</span> 'b <span class="hljs-number">2</span> 'c <span class="hljs-number">3</span>}]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))  <span class="hljs-comment">; =&gt; 3</span>

<span class="hljs-comment">;; 提供默认值</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:keys</span> [a b c] <span class="hljs-symbol">:or</span> {c <span class="hljs-number">0</span>}} {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span>}]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b c))  <span class="hljs-comment">; =&gt; 3</span>

<span class="hljs-comment">;; 使用 :as 保留原始映射</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:keys</span> [a b] <span class="hljs-symbol">:as</span> m} {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span> <span class="hljs-symbol">:c</span> <span class="hljs-number">3</span>}]
  [a b m])  <span class="hljs-comment">; =&gt; [1 2 {:a 1 :b 2 :c 3}]</span>
</div></code></pre>
<h2 id="%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84">函数参数解构</h2>
<p>解构在函数参数中特别有用：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 向量解构在函数参数中</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> first-two-sum [[x y]]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x y))

(<span class="hljs-name">first-two-sum</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])  <span class="hljs-comment">; =&gt; 3</span>

<span class="hljs-comment">;; 映射解构在函数参数中</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> create-person [{<span class="hljs-symbol">:keys</span> [name age city] <span class="hljs-symbol">:or</span> {city <span class="hljs-string">"Unknown"</span>}}]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> name <span class="hljs-string">" is "</span> age <span class="hljs-string">" years old, lives in "</span> city))

(<span class="hljs-name">create-person</span> {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Alice"</span> <span class="hljs-symbol">:age</span> <span class="hljs-number">30</span>}) 
<span class="hljs-comment">; =&gt; "Alice is 30 years old, lives in Unknown"</span>

(<span class="hljs-name">create-person</span> {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Bob"</span> <span class="hljs-symbol">:age</span> <span class="hljs-number">25</span> <span class="hljs-symbol">:city</span> <span class="hljs-string">"New York"</span>})
<span class="hljs-comment">; =&gt; "Bob is 25 years old, lives in New York"</span>
</div></code></pre>
<h2 id="%E5%B5%8C%E5%A5%97%E8%A7%A3%E6%9E%84">嵌套解构</h2>
<p>Clojure 支持嵌套解构，让你可以直接从复杂数据结构中提取值：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 嵌套向量解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [[[a b] [c d]] [[<span class="hljs-number">1</span> <span class="hljs-number">2</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]]]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b c d))  <span class="hljs-comment">; =&gt; 10</span>

<span class="hljs-comment">;; 嵌套映射解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:keys</span> [name address] 
       <span class="hljs-symbol">:or</span> {address {<span class="hljs-symbol">:city</span> <span class="hljs-string">"Unknown"</span>}}} 
      {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Charlie"</span> 
       <span class="hljs-symbol">:address</span> {<span class="hljs-symbol">:street</span> <span class="hljs-string">"123 Main St"</span> 
                 <span class="hljs-symbol">:city</span> <span class="hljs-string">"Boston"</span>}}]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> name <span class="hljs-string">" lives in "</span> (<span class="hljs-symbol">:city</span> address)))
<span class="hljs-comment">; =&gt; "Charlie lives in Boston"</span>

<span class="hljs-comment">;; 混合解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:keys</span> [name {<span class="hljs-symbol">:keys</span> [street city]}] <span class="hljs-symbol">:as</span> person}
      {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Diana"</span> 
       <span class="hljs-symbol">:address</span> {<span class="hljs-symbol">:street</span> <span class="hljs-string">"456 Elm St"</span> 
                 <span class="hljs-symbol">:city</span> <span class="hljs-string">"Chicago"</span>}}]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> name <span class="hljs-string">" lives at "</span> street <span class="hljs-string">", "</span> city))
<span class="hljs-comment">; =&gt; "Diana lives at 456 Elm St, Chicago"</span>
</div></code></pre>
<h2 id="%E5%AE%9E%E9%99%85%E7%94%A8%E4%BE%8B">实际用例</h2>
<h3 id="1-%E5%A4%84%E7%90%86-api-%E5%93%8D%E5%BA%94">1. 处理 API 响应</h3>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> process-user-response [{<span class="hljs-symbol">:keys</span> [data errors] <span class="hljs-symbol">:as</span> response}]
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> errors
    (<span class="hljs-name">println</span> <span class="hljs-string">"Errors:"</span> errors)
    (<span class="hljs-name">println</span> <span class="hljs-string">"User data:"</span> data)))
</div></code></pre>
<h3 id="2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">2. 状态管理</h3>
<p>在 Reagent (ClojureScript 的 React 封装) 中，通常这样使用解构管理组件状态：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> user-profile [{<span class="hljs-symbol">:keys</span> [user settings]}]
  [<span class="hljs-symbol">:div</span> 
   [<span class="hljs-symbol">:h1</span> (<span class="hljs-symbol">:name</span> user)]
   [<span class="hljs-symbol">:p</span> <span class="hljs-string">"Theme: "</span> (<span class="hljs-symbol">:theme</span> settings)]])
</div></code></pre>
<h3 id="3-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C">3. 数据库查询结果</h3>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> format-search-results [{<span class="hljs-symbol">:keys</span> [results metadata]}]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"Found "</span> (<span class="hljs-symbol">:count</span> metadata) <span class="hljs-string">" results: "</span> results))
</div></code></pre>
<h2 id="%E7%BB%83%E4%B9%A0">练习</h2>
<ol>
<li>
<p>编写一个函数，使用解构从向量 <code>[1 2 3]</code> 中提取第一个和最后一个元素。</p>
</li>
<li>
<p>为一个接受映射参数的函数添加解构，提取 <code>:name</code>、<code>:age</code> 和 <code>:occupation</code>，并为 <code>:occupation</code> 提供默认值 <code>&quot;Unknown&quot;</code>。</p>
</li>
<li>
<p>使用嵌套解构，从这个数据结构中提取城市和邮编：</p>
</li>
</ol>
<pre class="hljs"><code><div>{<span class="hljs-symbol">:name</span> <span class="hljs-string">"Eve"</span>, <span class="hljs-symbol">:address</span> {<span class="hljs-symbol">:street</span> <span class="hljs-string">"789 Pine St"</span>, <span class="hljs-symbol">:city</span> <span class="hljs-string">"Seattle"</span>, <span class="hljs-symbol">:zip</span> <span class="hljs-string">"98101"</span>}}
</div></code></pre>
<ol start="4">
<li>编写一个函数，使用 <code>:as</code> 保留原始映射，同时提取 <code>:id</code> 和 <code>:name</code>。</li>
</ol>
<p>解构是 Clojure 函数式编程风格的重要部分，它使代码更加声明式，减少中间变量，提高可读性。掌握解构后，你会发现处理复杂数据结构变得异常简洁和直观。</p>
<h1 id="18-%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-mutable-state-and-reference-types">18. 可变状态与引用类型 (Mutable State and Reference Types)</h1>
<p>虽然 Clojure 强调不可变性，但现实世界的应用经常需要管理可变状态。Clojure 提供了几种引用类型，它们在保持 Clojure 核心原则的同时，安全地管理可变状态。</p>
<h2 id="%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99">核心原则</h2>
<p>在 Clojure 中，状态管理遵循这些原则：</p>
<ol>
<li><strong>不可变数据</strong>：数据结构本身永远不会改变</li>
<li><strong>状态是标识+值+时间</strong>：标识（identity）随时间变化，持有不同的不可变值</li>
<li><strong>显式状态</strong>：状态变化是显式的，而不是隐含在变量赋值中</li>
</ol>
<h2 id="%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</h2>
<p>Clojure 提供四种主要的引用类型，每种用于不同场景：</p>
<h3 id="1-atoms---%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81">1. Atoms - 独立的同步状态</h3>
<p>Atoms 提供无协调的同步状态变更。它们适合单个值的独立更新：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 创建 atom</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> counter (<span class="hljs-name"><span class="hljs-builtin-name">atom</span></span> <span class="hljs-number">0</span>))

<span class="hljs-comment">;; 读取值</span>
@counter  <span class="hljs-comment">; =&gt; 0</span>
(<span class="hljs-name"><span class="hljs-builtin-name">deref</span></span> counter)  <span class="hljs-comment">; 等价于 @counter</span>

<span class="hljs-comment">;; 更新值</span>
(<span class="hljs-name"><span class="hljs-builtin-name">swap!</span></span> counter inc)  <span class="hljs-comment">; 原子地递增</span>
(<span class="hljs-name"><span class="hljs-builtin-name">swap!</span></span> counter + <span class="hljs-number">5</span>)  <span class="hljs-comment">; 原子地加5</span>
(<span class="hljs-name"><span class="hljs-builtin-name">reset!</span></span> counter <span class="hljs-number">100</span>)  <span class="hljs-comment">; 设置为新值（不考虑旧值）</span>

<span class="hljs-comment">;; 在函数中使用</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> next-id []
  (<span class="hljs-name"><span class="hljs-builtin-name">swap!</span></span> counter inc))

(<span class="hljs-name">next-id</span>)  <span class="hljs-comment">; =&gt; 1</span>
(<span class="hljs-name">next-id</span>)  <span class="hljs-comment">; =&gt; 2</span>
</div></code></pre>
<p>Atoms 保证对单个值的更新是原子的、一致的、隔离的，但不提供多个值之间的协调。</p>
<h3 id="2-refs---%E5%8D%8F%E8%B0%83%E7%9A%84%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81">2. Refs - 协调的同步状态</h3>
<p>Refs 用于需要协调多个引用之间变更的场景，使用软件事务内存 (STM)：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 创建 refs</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> account-a (<span class="hljs-name"><span class="hljs-builtin-name">ref</span></span> <span class="hljs-number">1000</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> account-b (<span class="hljs-name"><span class="hljs-builtin-name">ref</span></span> <span class="hljs-number">500</span>))

<span class="hljs-comment">;; 读取值</span>
@account-a  <span class="hljs-comment">; =&gt; 1000</span>

<span class="hljs-comment">;; 在事务中更新多个 refs</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> transfer [from to amount]
  (<span class="hljs-name"><span class="hljs-builtin-name">dosync</span></span>  <span class="hljs-comment">; 开始事务</span>
   (<span class="hljs-name"><span class="hljs-builtin-name">alter</span></span> from - amount)
   (<span class="hljs-name"><span class="hljs-builtin-name">alter</span></span> to + amount)))

(<span class="hljs-name">transfer</span> account-a account-b <span class="hljs-number">200</span>)
@account-a  <span class="hljs-comment">; =&gt; 800</span>
@account-b  <span class="hljs-comment">; =&gt; 700</span>
</div></code></pre>
<p>Refs 保证多个引用的更新要么全部成功，要么全部失败，保持数据一致性。</p>
<h3 id="3-agents---%E5%BC%82%E6%AD%A5%E7%8B%AC%E7%AB%8B%E7%8A%B6%E6%80%81">3. Agents - 异步独立状态</h3>
<p>Agents 用于异步、独立的状态变更，不阻塞调用线程：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 创建 agent</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> logger (<span class="hljs-name"><span class="hljs-builtin-name">agent</span></span> []))

<span class="hljs-comment">;; 发送异步更新</span>
(<span class="hljs-name"><span class="hljs-builtin-name">send</span></span> logger conj <span class="hljs-string">"Log entry 1"</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">send</span></span> logger conj <span class="hljs-string">"Log entry 2"</span>)

<span class="hljs-comment">;; 等待所有操作完成</span>
(<span class="hljs-name"><span class="hljs-builtin-name">await</span></span> logger)

<span class="hljs-comment">;; 读取值</span>
@logger  <span class="hljs-comment">; =&gt; ["Log entry 1" "Log entry 2"]</span>

<span class="hljs-comment">;; 错误处理</span>
(<span class="hljs-name"><span class="hljs-builtin-name">agent-error</span></span> logger)  <span class="hljs-comment">; 检查错误</span>
(<span class="hljs-name"><span class="hljs-builtin-name">restart-agent</span></span> logger [])  <span class="hljs-comment">; 重启 agent</span>
</div></code></pre>
<p>Agents 适合后台任务，比如日志记录、缓存更新、批处理操作等。</p>
<h3 id="4-vars---%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">4. Vars - 动态作用域</h3>
<p>Vars 与 <code>def</code> 创建，通常用于全局配置，但也可以动态重新绑定：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 创建 var</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> ^<span class="hljs-symbol">:dynamic</span> *db-connection* <span class="hljs-literal">nil</span>)

<span class="hljs-comment">;; 动态重新绑定</span>
(<span class="hljs-name">binding</span> [*db-connection* <span class="hljs-string">"test-db"</span>]
  (<span class="hljs-name">println</span> <span class="hljs-string">"Using database:"</span> *db-connection*))  <span class="hljs-comment">; =&gt; "Using database: test-db"</span>

<span class="hljs-comment">;; 外部访问</span>
(<span class="hljs-name">println</span> *db-connection*)  <span class="hljs-comment">; =&gt; nil</span>
</div></code></pre>
<p>Vars 应该谨慎使用，主要用于配置和可选特性开关，而不是业务状态。</p>
<h2 id="%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">状态管理的最佳实践</h2>
<ol>
<li><strong>最小化状态</strong>：只在必要时使用可变状态</li>
<li><strong>封装状态</strong>：将状态管理封装在少数函数中</li>
<li><strong>使用不可变数据</strong>：状态容器中存储不可变数据</li>
<li><strong>优先选择 Atoms</strong>：对于简单场景，Atoms 通常足够</li>
<li><strong>避免全局状态</strong>：尽可能将状态作为参数传递</li>
<li><strong>使用 STM 保证一致性</strong>：当多个值需要保持一致时，使用 Refs</li>
</ol>
<h2 id="%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90%E8%B4%AD%E7%89%A9%E8%BD%A6">实际例子：购物车</h2>
<pre class="hljs"><code><div><span class="hljs-comment">;; 使用 atom 管理购物车状态</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> cart (<span class="hljs-name"><span class="hljs-builtin-name">atom</span></span> {<span class="hljs-symbol">:items</span> [] <span class="hljs-symbol">:total</span> <span class="hljs-number">0</span>}))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add-item [item]
  (<span class="hljs-name"><span class="hljs-builtin-name">swap!</span></span> cart (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [current-cart]
                (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [new-items (<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> (<span class="hljs-symbol">:items</span> current-cart) item)
                      new-total (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-symbol">:total</span> current-cart) (<span class="hljs-symbol">:price</span> item))]
                  {<span class="hljs-symbol">:items</span> new-items <span class="hljs-symbol">:total</span> new-total}))))

<span class="hljs-comment">;; 添加商品</span>
(<span class="hljs-name">add-item</span> {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Book"</span> <span class="hljs-symbol">:price</span> <span class="hljs-number">20</span>})
(<span class="hljs-name">add-item</span> {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Pen"</span> <span class="hljs-symbol">:price</span> <span class="hljs-number">2</span>})

<span class="hljs-comment">;; 查看购物车</span>
@cart  <span class="hljs-comment">; =&gt; {:items [{:name "Book" :price 20} {:name "Pen" :price 2}], :total 22}</span>
</div></code></pre>
<h2 id="%E7%BB%83%E4%B9%A0">练习</h2>
<ol>
<li>
<p>创建一个 atom 作为计数器，编写函数实现递增、递减和重置功能。</p>
</li>
<li>
<p>使用 refs 实现一个银行账户系统，支持转账操作。</p>
</li>
<li>
<p>使用 agent 实现一个简单的消息队列，支持添加消息和处理消息。</p>
</li>
<li>
<p>创建一个动态 var 作为日志级别，使用 binding 临时改变它。</p>
</li>
</ol>
<p>Clojure 的引用类型设计精妙，让开发者可以在需要时安全地管理状态，同时不牺牲函数式编程的核心优势。通过理解每种引用类型的适用场景，你可以构建既强大又可维护的应用程序。</p>
<h1 id="19-%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97-lazy-sequences">19. 惰性序列 (Lazy Sequences)</h1>
<p>惰性序列是 Clojure 的核心特性之一，它允许创建理论上无限的序列，只在需要时计算元素。这不仅节省内存，还能简化代码，让开发者以声明式方式处理数据流。</p>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97">什么是惰性序列？</h2>
<p>惰性序列是&quot;按需计算&quot;的序列。序列中的元素只在被访问时计算，而不是在序列创建时计算所有元素。</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; range 创建惰性序列</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> naturals (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>))  <span class="hljs-comment">; 无限序列 0, 1, 2, 3...</span>

<span class="hljs-comment">;; 只计算需要的部分</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> naturals)  <span class="hljs-comment">; =&gt; (0 1 2 3 4 5 6 7 8 9)</span>

<span class="hljs-comment">;; 不会阻塞或耗尽内存</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-builtin-name">drop</span></span> <span class="hljs-number">10000</span> naturals))  <span class="hljs-comment">; =&gt; (10000 10001 10002 10003 10004)</span>
</div></code></pre>
<h2 id="%E5%88%9B%E5%BB%BA%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97">创建惰性序列</h2>
<p>Clojure 提供多种方式创建惰性序列：</p>
<h3 id="1-%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">1. 使用内置函数</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; range - 数字序列</span>
(<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">5</span>)          <span class="hljs-comment">; =&gt; (0 1 2 3 4)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">2</span>)     <span class="hljs-comment">; =&gt; (1 3 5 7 9)</span>

<span class="hljs-comment">;; repeat - 重复元素</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-builtin-name">repeat</span></span> <span class="hljs-string">"hello"</span>))  <span class="hljs-comment">; =&gt; ("hello" "hello" "hello" "hello" "hello")</span>

<span class="hljs-comment">;; repeatedly - 重复调用函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">repeatedly</span> #(<span class="hljs-name"><span class="hljs-builtin-name">rand-int</span></span> <span class="hljs-number">10</span>)))  <span class="hljs-comment">; =&gt; 随机整数序列</span>

<span class="hljs-comment">;; iterate - 迭代应用函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> (<span class="hljs-name"><span class="hljs-builtin-name">iterate</span></span> inc <span class="hljs-number">1</span>))  <span class="hljs-comment">; =&gt; (1 2 3 4 5 6 7 8 9 10)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> (<span class="hljs-name"><span class="hljs-builtin-name">iterate</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> <span class="hljs-number">2</span> %) <span class="hljs-number">1</span>))  <span class="hljs-comment">; =&gt; (1 2 4 8 16 32 64 128 256 512)</span>
</div></code></pre>
<h3 id="2-%E4%BD%BF%E7%94%A8-lazy-seq-%E5%AE%8F">2. 使用 <code>lazy-seq</code> 宏</h3>
<p><code>lazy-seq</code> 允许创建自定义惰性序列：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 斐波那契数列</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fib-seq
  ([] (<span class="hljs-name">fib-seq</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>))
  ([a b] (<span class="hljs-name"><span class="hljs-builtin-name">lazy-seq</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> a (<span class="hljs-name">fib-seq</span> b (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))))))

(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> (<span class="hljs-name">fib-seq</span>))  <span class="hljs-comment">; =&gt; (0 1 1 2 3 5 8 13 21 34)</span>
</div></code></pre>
<h3 id="3-%E4%BD%BF%E7%94%A8-for-%E5%92%8C-map-%E7%AD%89%E5%87%BD%E6%95%B0">3. 使用 <code>for</code> 和 <code>map</code> 等函数</h3>
<p>这些函数返回惰性序列：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; for 表达式</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> (<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [x (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>)
               y (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> x)]
           [x y]))

<span class="hljs-comment">;; map 函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> % %) (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>)))  <span class="hljs-comment">; 平方数</span>
</div></code></pre>
<h2 id="%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97%E7%9A%84%E7%89%B9%E6%80%A7">惰性序列的特性</h2>
<h3 id="1-%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AE%A1%E7%AE%97">1. 一次性计算</h3>
<p>每个元素只计算一次，结果会被缓存：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> slow-seq (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">do</span></span> (<span class="hljs-name">Thread/sleep</span> <span class="hljs-number">1000</span>) %) (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">5</span>)))

<span class="hljs-comment">;; 第一次访问会慢</span>
(<span class="hljs-name"><span class="hljs-builtin-name">time</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> slow-seq))  <span class="hljs-comment">; 约 1 秒</span>

<span class="hljs-comment">;; 后续访问缓存的结果</span>
(<span class="hljs-name"><span class="hljs-builtin-name">time</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> slow-seq))  <span class="hljs-comment">; 几乎瞬间</span>
</div></code></pre>
<h3 id="2-%E6%97%A0%E9%99%90%E5%BA%8F%E5%88%97">2. 无限序列</h3>
<p>可以创建理论上无限的序列：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 无限斐波那契序列</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> fibs (<span class="hljs-name">lazy-cat</span> [<span class="hljs-number">0</span> <span class="hljs-number">1</span>] (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> + fibs (<span class="hljs-name"><span class="hljs-builtin-name">rest</span></span> fibs))))
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">15</span> fibs)  <span class="hljs-comment">; =&gt; (0 1 1 2 3 5 8 13 21 34 55 89 144 233 377)</span>

<span class="hljs-comment">;; 无限随机数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> random-nums (<span class="hljs-name">repeatedly</span> #(<span class="hljs-name"><span class="hljs-builtin-name">rand-int</span></span> <span class="hljs-number">100</span>)))
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> random-nums)
</div></code></pre>
<h3 id="3-%E9%93%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2">3. 链式转换</h3>
<p>惰性序列可以链式转换，只在需要时计算：</p>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> processed
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>)
       (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even?)    <span class="hljs-comment">; 只保留偶数</span>
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> % %))    <span class="hljs-comment">; 平方</span>
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> str)         <span class="hljs-comment">; 转成字符串</span>
       (<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span>)))       <span class="hljs-comment">; 只取前10个</span>

<span class="hljs-comment">;; 此时还未计算</span>
processed

<span class="hljs-comment">;; 现在计算</span>
(<span class="hljs-name"><span class="hljs-builtin-name">doall</span></span> processed)  <span class="hljs-comment">; =&gt; ("0" "4" "16" "36" "64" "100" "169"...)</span>

<span class="hljs-comment">;; 使用 doall 强制计算整个序列</span>
</div></code></pre>
<h2 id="%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">惰性序列的实际应用</h2>
<h3 id="1-%E5%A4%84%E7%90%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86">1. 处理大数据集</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 惰性读取大文件</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> lazy-lines [filename]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [rdr (<span class="hljs-name">clojure.java.io/reader</span> filename)]
    (<span class="hljs-name"><span class="hljs-builtin-name">reify</span></span>
      clojure.lang.Seqable
      (<span class="hljs-name"><span class="hljs-builtin-name">seq</span></span> [_] (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> clojure.string/trim-newline
                    (<span class="hljs-name"><span class="hljs-builtin-name">line-seq</span></span> rdr)))
      java.io.Closeable
      (<span class="hljs-name">close</span> [_] (<span class="hljs-name">.close</span> rdr)))))

<span class="hljs-comment">;; 只处理需要的行</span>
(<span class="hljs-name"><span class="hljs-builtin-name">with-open</span></span> [lines (<span class="hljs-name">lazy-lines</span> <span class="hljs-string">"large-file.txt"</span>)]
  (<span class="hljs-name"><span class="hljs-builtin-name">doseq</span></span> [line (<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">100</span> lines)]  <span class="hljs-comment">; 只读取前100行</span>
    (<span class="hljs-name">println</span> line)))
</div></code></pre>
<h3 id="2-%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86">2. 事件流处理</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 模拟事件流</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> event-stream
  (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [id] {<span class="hljs-symbol">:id</span> id <span class="hljs-symbol">:type</span> (<span class="hljs-name">rand-nth</span> [<span class="hljs-symbol">:click</span> <span class="hljs-symbol">:scroll</span> <span class="hljs-symbol">:hover</span>]) <span class="hljs-symbol">:time</span> (<span class="hljs-name">System/currentTimeMillis</span>)})
       (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>)))

<span class="hljs-comment">;; 处理点击事件</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> click-events
  (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-symbol">:type</span> %) <span class="hljs-symbol">:click</span>) event-stream))

<span class="hljs-comment">;; 只获取前5个点击事件</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">5</span> click-events)
</div></code></pre>
<h3 id="3-%E6%97%A0%E9%99%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3. 无限数据结构</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 生成所有素数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> primes
  (<span class="hljs-name"><span class="hljs-builtin-name">letfn</span></span> [(<span class="hljs-name">prime?</span> [n primes-so-far]
            (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name">some</span> #(<span class="hljs-name"><span class="hljs-builtin-name">zero?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">rem</span></span> n %)) (<span class="hljs-name"><span class="hljs-builtin-name">take-while</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> % %) n) primes-so-far))))]
    (<span class="hljs-name"><span class="hljs-builtin-name">lazy-seq</span></span>
     (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> #(<span class="hljs-name">prime?</span> % primes) (<span class="hljs-name"><span class="hljs-builtin-name">iterate</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">2</span> %) <span class="hljs-number">3</span>))))))

(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">20</span> primes)  <span class="hljs-comment">; =&gt; (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71)</span>
</div></code></pre>
<h2 id="%E6%83%B0%E6%80%A7%E5%BA%8F%E5%88%97%E7%9A%84%E9%99%B7%E9%98%B1">惰性序列的陷阱</h2>
<h3 id="1-%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96">1. 意外的具体化</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 危险：这会尝试具体化整个无限序列！</span>
(<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>))  <span class="hljs-comment">; 不要这样做！</span>

<span class="hljs-comment">;; 安全：限制范围</span>
(<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">1000</span> (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>)))  <span class="hljs-comment">; =&gt; 1000</span>
</div></code></pre>
<h3 id="2-%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">2. 资源泄漏</h3>
<p>惰性序列可能持有资源引用，需要小心处理：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 危险：文件描述符可能不会及时关闭</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> lines (<span class="hljs-name"><span class="hljs-builtin-name">line-seq</span></span> (<span class="hljs-name">clojure.java.io/reader</span> <span class="hljs-string">"file.txt"</span>)))

<span class="hljs-comment">;; 安全：使用 with-open 确保资源释放</span>
(<span class="hljs-name"><span class="hljs-builtin-name">with-open</span></span> [rdr (<span class="hljs-name">clojure.java.io/reader</span> <span class="hljs-string">"file.txt"</span>)]
  (<span class="hljs-name"><span class="hljs-builtin-name">doseq</span></span> [line (<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">10</span> (<span class="hljs-name"><span class="hljs-builtin-name">line-seq</span></span> rdr))]  <span class="hljs-comment">; 只处理前10行</span>
    (<span class="hljs-name">println</span> line)))
</div></code></pre>
<h3 id="3-%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91">3. 性能考虑</h3>
<p>过度链式转换可能导致性能问题：</p>
<pre class="hljs"><code><div><span class="hljs-comment">;; 多次遍历</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> result
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1000000</span>)
       (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even?)
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> inc)
       (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> % <span class="hljs-number">100</span>))
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> str)))

<span class="hljs-comment">;; 优化：减少遍历次数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> optimized-result
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">1000000</span>)
       (<span class="hljs-name">eduction</span>
         (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even?)
         (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> inc)
         (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> % <span class="hljs-number">100</span>))
         (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> str))
       (<span class="hljs-name"><span class="hljs-builtin-name">into</span></span> [])))
</div></code></pre>
<h2 id="%E7%BB%83%E4%B9%A0">练习</h2>
<ol>
<li>
<p>创建一个生成所有3的倍数的惰性序列。</p>
</li>
<li>
<p>使用惰性序列实现一个无限循环，每秒打印当前时间（提示：使用 <code>repeatedly</code> 和 <code>Thread/sleep</code>）。</p>
</li>
<li>
<p>创建一个函数，接收一个序列，返回只包含连续重复元素的惰性序列。例如，<code>(1 1 2 2 2 3 3)</code> 变成 <code>(1 2 3)</code>。</p>
</li>
<li>
<p>使用惰性序列实现一个简单的分页系统，每次获取下一页数据。</p>
</li>
</ol>
<p>惰性序列是 Clojure 强大表达能力的关键部分，它让开发者能够以声明式方式处理潜在无限的数据流。理解惰性和及早求值的平衡，是编写高效 Clojure 代码的重要技能。</p>
<h1 id="20-%E6%80%BB%E7%BB%93%E4%B8%8E%E4%B8%8B%E4%B8%80%E6%AD%A5">20. 总结与下一步</h1>
<p>恭喜你完成了这份 Clojure 入门指南！通过学习基础知识，你已经掌握了这门强大语言的核心概念。让我们回顾一下重要的知识点，并讨论如何继续你的 Clojure 之旅。</p>
<h2 id="%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE">核心概念回顾</h2>
<ol>
<li><strong>一切皆表达式</strong>：Clojure 中没有语句，只有表达式，每个表达式都有返回值</li>
<li><strong>数据结构为核心</strong>：列表、向量、映射和集合是 Clojure 的基础构建块</li>
<li><strong>不可变性</strong>：数据结构默认不可变，转换产生新值而不是修改原值</li>
<li><strong>函数是一等公民</strong>：函数可以作为参数传递、作为返回值、存储在数据结构中</li>
<li><strong>宏系统</strong>：Clojure 代码是数据，宏允许你扩展语言本身</li>
<li><strong>管理状态</strong>：Atoms、Refs、Agents 和 Vars 提供安全的可变状态管理</li>
<li><strong>惰性求值</strong>：序列默认是惰性的，允许处理无限数据流</li>
</ol>
<h2 id="%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</h2>
<ul>
<li><strong>默认不可变</strong>：尽可能使用不可变数据和纯函数</li>
<li><strong>小而专注的函数</strong>：编写单一职责的函数，它们易于组合</li>
<li><strong>数据转换管道</strong>：使用 threading 宏创建清晰的数据转换流程</li>
<li><strong>避免副作用</strong>：将副作用推向程序边界</li>
<li><strong>使用解构</strong>：让代码更简洁，减少中间变量</li>
<li><strong>拥抱 REPL</strong>：交互式开发是 Clojure 的核心工作流</li>
</ul>
<h2 id="%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84">学习路径</h2>
<h3 id="1-%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA">1. 基础巩固</h3>
<ul>
<li>完成 <a href="https://4clojure.8thlight.com/">4Clojure</a> 挑战</li>
<li>阅读 <a href="https://www.braveclojure.com/">Clojure for the Brave and True</a></li>
<li>完成 <a href="https://github.com/functional-koans/clojure-koans">Clojure Koans</a></li>
</ul>
<h3 id="2-%E6%B7%B1%E5%85%A5%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">2. 深入核心概念</h3>
<ul>
<li>阅读 <a href="https://www.manning.com/books/the-joy-of-clojure">The Joy of Clojure</a></li>
<li>学习 <a href="https://clojure.org/reference/reducers">Reducers</a> 和 <a href="https://clojure.org/reference/transducers">Transducers</a></li>
<li>了解 <a href="https://github.com/clojure/core.async">core.async</a> 用于异步编程</li>
</ul>
<h3 id="3-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE">3. 实战项目</h3>
<ul>
<li><strong>Web 开发</strong>：使用 <a href="https://github.com/ring-clojure/ring">Ring</a> + <a href="https://github.com/weavejester/compojure">Compojure</a> 或 <a href="https://github.com/pedestal/pedestal">Pedestal</a></li>
<li><strong>前端开发</strong>：使用 <a href="https://clojurescript.org/">ClojureScript</a> + <a href="https://reagent-project.github.io/">Reagent</a> 或 <a href="https://github.com/omcljs/om">Om</a></li>
<li><strong>数据处理</strong>：使用 <a href="http://incanter.org/">Incanter</a> 或 <a href="https://github.com/scicloj/tablecloth">Tablecloth</a></li>
<li><strong>系统工具</strong>：编写自动化脚本或命令行工具</li>
</ul>
<h3 id="4-%E7%A4%BE%E5%8C%BA%E5%8F%82%E4%B8%8E">4. 社区参与</h3>
<ul>
<li>加入 <a href="https://clojurians.slack.com/">Clojurians Slack</a> 或 <a href="https://clojurians.zulipchat.com/">Zulip</a></li>
<li>关注 <a href="https://www.reddit.com/r/Clojure/">Clojure Subreddit</a></li>
<li>参与 <a href="https://clojureverse.org/">ClojureVerse</a> 论坛</li>
<li>参加本地或线上 <a href="https://www.meetup.com/topics/clojure/">Clojure Meetups</a></li>
</ul>
<h2 id="%E6%8E%A8%E8%8D%90%E8%B5%84%E6%BA%90">推荐资源</h2>
<h3 id="%E4%B9%A6%E7%B1%8D">书籍</h3>
<ul>
<li><a href="https://www.braveclojure.com/">Clojure for the Brave and True</a> (免费在线版)</li>
<li><a href="https://www.manning.com/books/the-joy-of-clojure">The Joy of Clojure</a></li>
<li><a href="https://www.apress.com/gp/book/9781430272311">Practical Clojure</a></li>
</ul>
<h3 id="%E8%A7%86%E9%A2%91">视频</h3>
<ul>
<li><a href="https://www.infoq.com/presentations/clojure-concurrency/">Stuart Halloway's Clojure Concurrency</a></li>
<li><a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich">Rich Hickey's talks</a> (Clojure 作者)</li>
<li><a href="https://clojuredesign.club/">Functional Design in Clojure podcast</a></li>
</ul>
<h3 id="%E5%B7%A5%E5%85%B7">工具</h3>
<ul>
<li><a href="https://calva.io/">Calva</a> - VS Code 的 Clojure 插件</li>
<li><a href="https://docs.cider.mx/">CIDER</a> - Emacs 的 Clojure 环境</li>
<li><a href="https://github.com/cognitect-labs/REBL-distro">REBL</a> - 数据浏览器</li>
<li><a href="https://figwheel.org/">Figwheel</a> - ClojureScript 热重载</li>
</ul>
<h2 id="%E9%BC%93%E5%8A%B1">鼓励</h2>
<p>学习 Clojure 是一段值得的旅程。虽然函数式编程和不可变数据的概念可能起初有些陌生，但坚持下去会带来丰厚的回报。Clojure 社区以友好和支持著称，不要犹豫寻求帮助。</p>
<p>正如 Rich Hickey (Clojure 作者) 所说：</p>
<blockquote>
<p>&quot;简单不是容易的。简单是通过深思熟虑的设计和对复杂性的拒绝达到的。&quot;</p>
</blockquote>
<p>继续练习，构建项目，向社区学习。Clojure 不仅仅是一门语言，它是一种思考软件的方式。祝你在 Clojure 之旅中取得成功！ ♥️</p>
<h2 id="%E9%99%84%E5%BD%95%E9%80%9F%E6%9F%A5%E8%A1%A8">附录：速查表</h2>
<h3 id="%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">基础语法</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 函数调用</span>
(<span class="hljs-name">function</span> arg1 arg2)

<span class="hljs-comment">;; 定义变量</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x <span class="hljs-number">42</span>)

<span class="hljs-comment">;; 定义函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> add [a b] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))

<span class="hljs-comment">;; 条件判断</span>
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> condition <span class="hljs-literal">true</span>-expr <span class="hljs-literal">false</span>-expr)
(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> condition expr1 expr2)

<span class="hljs-comment">;; 循环</span>
(<span class="hljs-name"><span class="hljs-builtin-name">loop</span></span> [x <span class="hljs-number">0</span>]
  (<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> x <span class="hljs-number">10</span>)
    (<span class="hljs-name">println</span> x)
    (<span class="hljs-name"><span class="hljs-builtin-name">recur</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">inc</span></span> x))))

<span class="hljs-comment">;; 解构</span>
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [[a b] [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]] (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b))
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [{<span class="hljs-symbol">:keys</span> [name age]} {<span class="hljs-symbol">:name</span> <span class="hljs-string">"Alice"</span> <span class="hljs-symbol">:age</span> <span class="hljs-number">30</span>}]
  (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> name <span class="hljs-string">" is "</span> age))
</div></code></pre>
<h3 id="%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C">集合操作</h3>
<pre class="hljs"><code><div><span class="hljs-comment">;; 向量</span>
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
(<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span>] <span class="hljs-number">3</span>)  <span class="hljs-comment">; =&gt; [1 2 3]</span>
(<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-number">1</span> <span class="hljs-number">4</span>)  <span class="hljs-comment">; =&gt; [1 4 3]</span>
(<span class="hljs-name"><span class="hljs-builtin-name">nth</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-number">1</span>)  <span class="hljs-comment">; =&gt; 2</span>

<span class="hljs-comment">;; 列表</span>
'(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> '(<span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-number">1</span>)  <span class="hljs-comment">; =&gt; (1 2 3)</span>

<span class="hljs-comment">;; 映射</span>
{<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span>}
(<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span>} <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span>)  <span class="hljs-comment">; =&gt; {:a 1 :b 2}</span>
(<span class="hljs-name"><span class="hljs-builtin-name">dissoc</span></span> {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span>} <span class="hljs-symbol">:a</span>)  <span class="hljs-comment">; =&gt; {:b 2}</span>
(<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span>} <span class="hljs-symbol">:a</span>)  <span class="hljs-comment">; =&gt; 1</span>
(<span class="hljs-symbol">:a</span> {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span>})  <span class="hljs-comment">; =&gt; 1</span>

<span class="hljs-comment">;; 集合</span>
#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>}
(<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span>} <span class="hljs-number">3</span>)  <span class="hljs-comment">; =&gt; #{1 2 3}</span>
(<span class="hljs-name"><span class="hljs-builtin-name">disj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">2</span>)  <span class="hljs-comment">; =&gt; #{1 3}</span>
(<span class="hljs-name">#</span>{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">2</span>)  <span class="hljs-comment">; =&gt; 2</span>
</div></code></pre>
<h3 id="%E5%87%BD%E6%95%B0%E5%BC%8F%E5%B7%A5%E5%85%B7">函数式工具</h3>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> inc [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])  <span class="hljs-comment">; =&gt; (2 3 4)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even? [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>])  <span class="hljs-comment">; =&gt; (2 4)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> + [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>])  <span class="hljs-comment">; =&gt; 10</span>
(<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">3</span> (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span>))  <span class="hljs-comment">; =&gt; (0 1 2)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">drop</span></span> <span class="hljs-number">2</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>])  <span class="hljs-comment">; =&gt; (3 4)</span>
</div></code></pre>
<h3 id="%E7%BA%BF%E7%A8%8B%E5%AE%8F">线程宏</h3>
<pre class="hljs"><code><div>(<span class="hljs-name"><span class="hljs-builtin-name">-&gt;</span></span> {<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span>}
    (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> <span class="hljs-symbol">:c</span> <span class="hljs-number">3</span>)
    (<span class="hljs-name">update</span> <span class="hljs-symbol">:a</span> inc))  <span class="hljs-comment">; =&gt; {:a 2 :b 2 :c 3}</span>

(<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]
     (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> inc)
     (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> even?))  <span class="hljs-comment">; =&gt; (2 4)</span>
</div></code></pre>
<p>现在，打开你的 REPL，开始 Clojure 之旅吧！</p>

</body>
</html>
